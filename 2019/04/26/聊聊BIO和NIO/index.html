
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>认真的人，自带光芒。</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="ZhangYang,"> 
    <meta name="description" content="FastDFS是什么？1.它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。2.特别适合以文件为载体的在线服务，如相册网站、视频网站,"> 
    <meta name="author" content="ZhangYang"> 
    <link rel="alternative" href="atom.xml" title="认真的人，自带光芒。" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head></html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">聊聊BIO和NIO</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">聊聊BIO和NIO</h1>
        <div class="stuff">
            <span>四月 26, 2019</span>
            

        </div>
        <div class="content markdown">
            <p>本文摘录文字部分摘录自：<a href="https://www.jianshu.com/p/ef418ccf2f7d" target="_blank" rel="noopener">https://www.jianshu.com/p/ef418ccf2f7d</a></p>
<h2 id="到底什么是“IO-Block”"><a href="#到底什么是“IO-Block”" class="headerlink" title="到底什么是“IO Block”"></a><strong>到底什么是“IO Block”</strong></h2><p>很多人说BIO不好，会“block”，但到底什么是IO的Block呢？考虑下面两种情况：  </p>
<ul>
<li>用系统调用read从socket里读取一段数据</li>
<li>用系统调用read从一个磁盘文件读取一段数据到内存  </li>
</ul>
<p>如果你的直觉告诉你，这两种都算“Block”，那么很遗憾，你的理解与Linux不同。Linux认为：<br>对于第一种情况，算作block，因为Linux无法知道网络上对方是否会发数据。如果没数据发过来，对于调用read的程序来说，就只能“等”。<br>对于第二种情况，不算做block。<br>是的，对于磁盘文件IO，Linux总是不视作Block。<br>你可能会说，这不科学啊，磁盘读写偶尔也会因为硬件而卡壳啊，怎么能不算Block呢？但实际就是不算。<br>一个解释是，所谓“Block”是指操作系统可以预见这个Block会发生才会主动Block。例如当读取TCP连接的数据时，如果发现Socket buffer里没有数据就可以确定定对方还没有发过来，于是Block；而对于普通磁盘文件的读写，也许磁盘运作期间会抖动，会短暂暂停，但是操作系统无法预见这种情况，只能视作不会Block，照样执行。<br>基于这个基本的设定，在讨论IO时，一定要严格区分网络IO和磁盘文件IO。NIO和后文讲到的IO多路复用只对网络IO有意义。<br>严格的说，O_NONBLOCK和IO多路复用，对标准输入输出描述符、管道和FIFO也都是有效的。但本文侧重于讨论高性能网络服务器下各种IO的含义和关系，所以本文做了简化，只提及网络IO和磁盘文件IO两种情况。</p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a><strong>BIO</strong></h2><p>有了Block的定义，就可以讨论BIO和NIO了。BIO是Blocking IO的意思。在类似于网络中进行read, write, connect一类的系统调用时会被卡住。<br>举个例子，当用read去读取网络的数据时，是无法预知对方是否已经发送数据的。因此在收到数据之前，能做的只有等待，直到对方把数据发过来，或者等到网络超时。<br>对于单线程的网络服务，这样做就会有卡死的问题。因为当等待时，整个线程会被挂起，无法执行，也无法做其他的工作。<br>顺便说一句，这种Block是不会影响同时运行的其他程序（进程）的，因为现代操作系统都是多任务的，任务之间的切换是抢占式的。这里Block只是指Block当前的进程。<br>于是，网络服务为了同时响应多个并发的网络请求，必须实现为多线程的。每个线程处理一个网络请求。线程数随着并发连接数线性增长。这的确能奏效。实际上2000年之前很多网络服务器就是这么实现的。但这带来两个问题：  </p>
<ul>
<li>线程越多，Context Switch就越多，而Context Switch是一个比较重的操作，会无谓浪费大量的CPU。</li>
<li>每个线程会占用一定的内存作为线程的栈。比如有1000个线程同时运行，每个占用1MB内存，就占用了1个G的内存。</li>
</ul>
<p>也许现在看来1GB内存不算什么，现在服务器上百G内存的配置现在司空见惯了。但是倒退20年，1G内存是很金贵的。并且，尽管现在通过使用大内存，可以轻易实现并发1万甚至10万的连接。但是水涨船高，如果是要单机撑1千万的连接呢？<br>问题的关键在于，当调用read接受网络请求时，有数据到了就用，没数据到时，实际上是可以干别的。使用大量线程，仅仅是因为Block发生，没有其他办法。<br>当然你可能会说，是不是可以弄个线程池呢？这样既能并发的处理请求，又不会产生大量线程。但这样会限制最大并发的连接数。比如你弄4个线程，那么最大4个线程都Block了就没法响应更多请求了。<br>要是操作IO接口时，操作系统能够总是直接告诉有没有数据，而不是Block去等就好了。于是，NIO登场。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a><strong>NIO</strong></h2><p>NIO是指将IO模式设为“Non-Blocking”模式。在Linux下，一般是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void setnonblocking(int fd) &#123;</span><br><span class="line">    int flags = fcntl(fd, F_GETFL, 0);</span><br><span class="line">    fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时，BIO和NIO的区别是什么呢？<br>在BIO模式下，调用read，如果发现没数据已经到达，就会Block住。<br>在NIO模式下，调用read，如果发现没数据已经到达，就会立刻返回-1, 并且errno被设为EAGAIN。<br>在有些文档中写的是会返回EWOULDBLOCK。实际上，在Linux下EAGAIN和EWOULDBLOCK是一样的，即#define EWOULDBLOCK EAGAIN  </p>
<p>于是，一段NIO的代码，大概就可以写成这个样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct timespec sleep_interval&#123;.tv_sec = 0, .tv_nsec = 1000&#125;;</span><br><span class="line">ssize_t nbytes;</span><br><span class="line">while (1) &#123;</span><br><span class="line">    /* 尝试读取 */</span><br><span class="line">    if ((nbytes = read(fd, buf, sizeof(buf))) &lt; 0) &#123;</span><br><span class="line">        if (errno == EAGAIN) &#123; // 没数据到</span><br><span class="line">            perror(&quot;nothing can be read&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            perror(&quot;fatal error&quot;);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; // 有数据</span><br><span class="line">        process_data(buf, nbytes);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理其他事情，做完了就等一会，再尝试</span><br><span class="line">    nanosleep(sleep_interval, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码很容易理解，就是轮询，不断的尝试有没有数据到达，有了就处理，没有(得到EWOULDBLOCK或者EAGAIN)就等一小会再试。这比之前BIO好多了，起码程序不会被卡死了。<br>但这样会带来两个新问题：  </p>
<p>1.如果有大量文件描述符都要等，那么就得一个一个的read。这会带来大量的Context Switch（read是系统调用，每调用一次就得在用户态和核心态切换一次）<br>2.休息一会的时间不好把握。这里是要猜多久之后数据才能到。等待时间设的太长，程序响应延迟就过大；设的太短，就会造成过于频繁的重试，干耗CPU而已。</p>
<p>要是操作系统能一口气告诉程序，哪些数据到了就好了。<br>于是IO多路复用被搞出来解决这个问题。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a><strong>IO多路复用</strong></h2><p>IO多路复用（IO Multiplexing) 是这么一种机制：程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”。<br>IO多路复用是要和NIO一起使用的。尽管在操作系统级别，NIO和IO多路复用是两个相对独立的事情。NIO仅仅是指IO API总是能立刻返回，不会被Blocking；而IO多路复用仅仅是操作系统提供的一种便利的通知机制。操作系统并不会强制这俩必须得一起用——你可以用NIO，但不用IO多路复用，就像上一节中的代码；也可以只用IO多路复用 + BIO，这时效果还是当前线程被卡住。但是，IO多路复用和NIO是要配合一起使用才有实际意义。因此，在使用IO多路复用之前，请总是先把fd设为O_NONBLOCK。  </p>
<p>操作系统级别提供了一些接口来支持IO多路复用，最老掉牙的是select和poll。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>
<p>它接受3个文件描述符的数组，分别监听读取(readfds)，写入(writefds)和异常(expectfds)事件。那么一个 IO多路复用的代码大概是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct timeval tv = &#123;.tv_sec = 1, .tv_usec = 0&#125;;</span><br><span class="line"></span><br><span class="line">ssize_t nbytes;</span><br><span class="line">while(1) &#123;</span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    setnonblocking(fd1);</span><br><span class="line">    setnonblocking(fd2);</span><br><span class="line">    FD_SET(fd1, &amp;read_fds);</span><br><span class="line">    FD_SET(fd2, &amp;read_fds);</span><br><span class="line">    // 把要监听的fd拼到一个数组里，而且每次循环都得重来一次...</span><br><span class="line">    if (select(FD_SETSIZE, &amp;read_fds, NULL, NULL, &amp;tv) &lt; 0) &#123; // block住，直到有事件到达</span><br><span class="line">        perror(&quot;select出错了&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">        if (FD_ISSET(i, &amp;read_fds)) &#123;</span><br><span class="line">            /* 检测到第[i]个读取fd已经收到了，这里假设buf总是大于到达的数据，所以可以一次read完 */</span><br><span class="line">            if ((nbytes = read(i, buf, sizeof(buf))) &gt;= 0) &#123;</span><br><span class="line">                process_data(nbytes, buf);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                perror(&quot;读取出错了&quot;);</span><br><span class="line">                exit(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，为了select需要构造一个fd数组（这里为了简化，没有构造要监听写入和异常事件的fd数组）。之后，用select监听了read_fds中的多个socket的读取时间。调用select后，程序会Block住，直到一个事件发生了，或者等到最大1秒钟(tv定义了这个时间长度）就返回。之后，需要遍历所有注册的fd，挨个检查哪个fd有事件到达(FD_ISSET返回true)。如果是，就说明数据已经到达了，可以读取fd了。读取后就可以进行数据的处理。<br>select有一些发指的缺点：  </p>
<ul>
<li>select能够支持的最大的fd数组的长度是1024。这对要处理高并发的web服务器是不可接受的。  </li>
<li>000fd数组按照监听的事件分为了3个数组，为了这3个数组要分配3段内存去构造，而且每次调用select前都要重设它们（因为select会改这3个数组)；调用select后，这3数组要从用户态复制一份到内核态；事件到达后，要遍历这3数组。很不爽。   </li>
<li>select返回后要挨个遍历fd，找到被“SET”的那些进行处理。这样比较低效。  </li>
<li>select是无状态的，即每次调用select，内核都要重新检查所有被注册的fd的状态。select返回后，这些状态就被返回了，内核不会记住它们；到了下一次调用，内核依然要重新检查一遍。于是查询的效率很低。</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong>poll</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br></pre></td></tr></table></figure>
<p>poll优化了select的一些问题。比如不再有3个数组，而是1个polldfd结构的数组了，并且也不需要每次重设了。数组的个数也没有了1024的限制。但其他的问题依旧：  </p>
<ul>
<li>依然是无状态的，性能的问题与select差不多一样；</li>
<li>应用程序仍然无法很方便的拿到那些“有事件发生的fd“，还是需要遍历所有注册的fd。</li>
</ul>
<p>目前来看，高性能的web服务器都不会使用select和poll。他们俩存在的意义仅仅是“兼容性”，因为很多操作系统都实现了这两个系统调用。<br>如果是追求性能的话，在BSD/macOS上提供了kqueue api；在Salorias中提供了/dev/poll（可惜该操作系统已经凉凉)；而在Linux上提供了epoll api。它们的出现彻底解决了select和poll的问题。Java NIO，nginx等在对应的平台的上都是使用这些api实现。</p>
<h2 id="用epoll实现的IO多路复用"><a href="#用epoll实现的IO多路复用" class="headerlink" title="用epoll实现的IO多路复用"></a><strong>用epoll实现的IO多路复用</strong></h2><p>epoll是Linux下的IO多路复用的实现。这里单开一章是因为它非常有代表性，并且Linux也是目前最广泛被作为服务器的操作系统。细致的了解epoll对整个IO多路复用的工作原理非常有帮助。</p>
<p>与select和poll不同，要使用epoll是需要先创建一下的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epfd = epoll_create(10);</span><br></pre></td></tr></table></figure></p>
<p>epoll_create在内核层创建了一个数据表，接口会返回一个“epoll的文件描述符”指向这个表。注意，接口参数是一个表达要监听事件列表的长度的数值。但不用太在意，因为epoll内部随后会根据事件注册和事件注销动态调整epoll中表格的大小。  </p>
<p>为什么epoll要创建一个用文件描述符来指向的表呢？这里有两个好处：</p>
<ul>
<li>epoll是有状态的，不像select和poll那样每次都要重新传入所有要监听的fd，这避免了很多无谓的数据复制。epoll的数据是用接口epoll_ctl来管理的（增、删、改）。</li>
<li>epoll文件描述符在进程被fork时，子进程是可以继承的。这可以给对多进程共享一份epoll数据，实现并行监听网络请求带来便利。</li>
</ul>
<p>epoll创建后，第二步是使用epoll_ctl接口来注册要监听的事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure></p>
<p>其中第一个参数就是上面创建的epfd。第二个参数op表示如何对文件名进行操作，共有3种。<br>EPOLL_CTL_ADD - 注册一个事件<br>EPOLL_CTL_DEL - 取消一个事件的注册<br>EPOLL_CTL_MOD - 修改一个事件的注册<br>第三个参数是要操作的fd，这里必须是支持NIO的fd（比如socket）。<br>第四个参数是一个epoll_event的类型的数据，表达了注册的事件的具体信息  </p>
<p>第三步，使用epoll_wait来等待事件的发生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *evlist, int maxevents, int timeout);</span><br></pre></td></tr></table></figure></p>
<p>特别留意，这一步是”block”的。只有当注册的事件至少有一个发生，或者timeout达到时，该调用才会返回。这与select和poll几乎一致。但不一样的地方是evlist，它是epoll_wait的返回数组，里面只包含那些被触发的事件对应的fd，而不是像select和poll那样返回所有注册的fd。</p>
<p>所有的基于IO多路复用的代码都会遵循这样的写法：注册——监听事件——处理——再注册，无限循环下去。</p>
<h2 id="epoll的优势"><a href="#epoll的优势" class="headerlink" title="epoll的优势"></a><strong>epoll的优势</strong></h2><p>为什么epoll的性能比select和poll要强呢？ select和poll每次都需要把完成的fd列表传入到内核，迫使内核每次必须从头扫描到尾。而epoll完全是反过来的。epoll在内核的数据被建立好了之后，每次某个被监听的fd一旦有事件发生，内核就直接标记之。epoll_wait调用时，会尝试直接读取到当时已经标记好的fd列表，如果没有就会进入等待状态。<br>同时，epoll_wait直接只返回了被触发的fd列表，这样上层应用写起来也轻松愉快，再也不用从大量注册的fd中筛选出有事件的fd了。<br>简单说就是select和poll的代价是”O(所有注册事件fd的数量)”，而epoll的代价是”O(发生事件fd的数量)”。于是，高性能网络服务器的场景特别适合用epoll来实现——因为大多数网络服务器都有这样的模式：同时要监听大量（几千，几万，几十万甚至更多）的网络连接，但是短时间内发生的事件非常少。<br>但是，假设发生事件的fd的数量接近所有注册事件fd的数量，那么epoll的优势就没有了，其性能表现会和poll和select差不多。</p>
<p>附上自己实现的BIO NIO AIO的简单通信代码：</p>
<h2 id="BIO-1"><a href="#BIO-1" class="headerlink" title="BIO"></a><strong>BIO</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.mldn.bio.server;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.mldn.info.HostInfo;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: ZhangYang</span><br><span class="line"> * @Date: 2019/4/9 20:56</span><br><span class="line"> */</span><br><span class="line">public class BIOEchoServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(HostInfo.PORT) ;// 设置监听端口</span><br><span class="line">        System.out.println(&quot;服务器端已经启动，监听的端口为：&quot; + HostInfo.PORT);</span><br><span class="line">        boolean flag = true ;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(10) ;</span><br><span class="line">        while(flag) &#123;</span><br><span class="line">            Socket client = serverSocket.accept() ;</span><br><span class="line">            executorService.submit(new EchoClientHandler(client)) ;</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown() ;</span><br><span class="line">        serverSocket.close() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class EchoClientHandler implements Runnable &#123;</span><br><span class="line">        private Socket client ; // 每一个客户端都需要启动一个任务(task)来执行。</span><br><span class="line">        private Scanner scanner ;</span><br><span class="line">        private PrintStream out ;</span><br><span class="line">        private boolean flag = true ;   // 循环标记</span><br><span class="line">        public EchoClientHandler(Socket client) &#123;</span><br><span class="line">            this.client = client ; // 保存每一个客户端操作</span><br><span class="line">            try &#123;</span><br><span class="line">                this.scanner = new Scanner(this.client.getInputStream()) ;</span><br><span class="line">                this.scanner.useDelimiter(&quot;\n&quot;) ; // 设置换行符</span><br><span class="line">                this.out = new PrintStream(this.client.getOutputStream()) ;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while(this.flag) &#123;</span><br><span class="line">                if (this.scanner.hasNext()) &#123;   // 现在有数据进行输入</span><br><span class="line">                    String val = this.scanner.next().trim() ; // 去掉多余的空格内容</span><br><span class="line">                    System.err.println(&quot;&#123;服务器端&#125;&quot; + val);</span><br><span class="line">                    if(&quot;byebye&quot;.equalsIgnoreCase(val)) &#123;</span><br><span class="line">                        this.out.println(&quot;ByeByeByte...&quot;);</span><br><span class="line">                        this.flag = false ;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        out.println(&quot;【ECHO】&quot; + val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.scanner.close();</span><br><span class="line">            this.out.close();</span><br><span class="line">            try &#123;</span><br><span class="line">                this.client.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.mldn.bio.client;</span><br><span class="line"></span><br><span class="line">import com.mldn.info.HostInfo;</span><br><span class="line">import com.mldn.util.inputUtil;</span><br><span class="line"></span><br><span class="line">import java.io.PrintStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: ZhangYang</span><br><span class="line"> * @Date: 2019/4/9 21:21</span><br><span class="line"> */</span><br><span class="line">public class BIOEchoClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Socket client = new Socket(HostInfo.HOST_NAME,HostInfo.PORT) ;  // 定义连接的主机信息</span><br><span class="line">        Scanner scan = new Scanner(client.getInputStream()) ;   // 获取服务器端的响应数据</span><br><span class="line">        scan.useDelimiter(&quot;\n&quot;) ;</span><br><span class="line">        PrintStream out = new PrintStream(client.getOutputStream()) ; // 向服务器端发送信息内容</span><br><span class="line">        boolean flag = true ; // 交互的标记</span><br><span class="line">        while(flag) &#123;</span><br><span class="line">            String inputData = inputUtil.getString(&quot;请输入要发送的内容：&quot;).trim() ;</span><br><span class="line">            out.println(inputData); // 把数据发送到服务器端上</span><br><span class="line">            if(scan.hasNext()) &#123;</span><br><span class="line">                String str = scan.next().trim() ;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">            if (&quot;byebye&quot;.equalsIgnoreCase(inputData)) &#123;</span><br><span class="line">                flag = false ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NIO-1"><a href="#NIO-1" class="headerlink" title="NIO"></a><strong>NIO</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package com.mldn.nio.server;</span><br><span class="line"></span><br><span class="line">import com.mldn.info.HostInfo;</span><br><span class="line"></span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: ZhangYang</span><br><span class="line"> * @Date: 2019/4/10 15:45</span><br><span class="line"> */</span><br><span class="line">public class NIOEchoServer &#123;</span><br><span class="line">    private static class EchoClientHandler implements Runnable&#123;</span><br><span class="line">        private SocketChannel clientChannel ; // 客户端通道</span><br><span class="line">        private boolean flag = true ; // 循环处理标记</span><br><span class="line">        public EchoClientHandler(SocketChannel clientChannel) &#123;</span><br><span class="line">            this.clientChannel = clientChannel ;</span><br><span class="line">            // 严格意义上来讲，当已经成功的连接上了服务器，并且需要进行进一步处理之前要发送一些消息给客户端</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(50) ; // 50个缓冲区</span><br><span class="line">            try &#123;</span><br><span class="line">                while(this.flag) &#123;  // 需要不断进行交互</span><br><span class="line">                    buffer.clear() ;    // 清空缓冲区</span><br><span class="line">                    int readCount = this.clientChannel.read(buffer) ; // 向缓冲区之中读取数据</span><br><span class="line">                    String readMessage = new String(buffer.array(),0,readCount).trim() ;</span><br><span class="line">                    String writeMessage = &quot;【ECHO】&quot; + readMessage + &quot;\n&quot; ; // 回应数据信息</span><br><span class="line">                    if(&quot;byebye&quot;.equalsIgnoreCase(readMessage)) &#123;</span><br><span class="line">                        writeMessage = &quot;【EXIT】拜拜，下次再见！&quot; ;</span><br><span class="line">                        this.flag = false ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 数据输入通过缓存的形式完成，而数据的输出同样需要进行缓存操作</span><br><span class="line">                    buffer.clear() ; // 为了写入新的返回数据而定义</span><br><span class="line">                    buffer.put(writeMessage.getBytes()) ; // 发送内容</span><br><span class="line">                    buffer.flip() ; // 重置缓冲区</span><br><span class="line">                    this.clientChannel.write(buffer) ;// 回应数据</span><br><span class="line">                &#125;</span><br><span class="line">                this.clientChannel.close();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 1、NIO的实现考虑到性能的问题以及响应时间问题，需要设置一个线程池，采用固定大小的线程池</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line">        // 2、NIO的处理是基于Channel控制的，所以有一个Selector就是负责管理所有的Channel</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        // 3、需要为其设置一个非阻塞的状态机制</span><br><span class="line">        serverSocketChannel.configureBlocking(false); // 非阻塞模式</span><br><span class="line">        // 4、服务器上需要提供有一个网络的监听端口</span><br><span class="line">        serverSocketChannel.bind(new InetSocketAddress(HostInfo.PORT));</span><br><span class="line">        // 5、需要设置一个Selector，作为一个选择器的出现，目的是管理所有的Channel</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        // 6、将当前的Channel注册到Selector之中</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); // 连接时处理</span><br><span class="line">        System.out.println(&quot;服务器已经启动成功，服务器的监听端口为：&quot; + HostInfo.PORT);</span><br><span class="line">        // 7、NIO采用的是轮询模式，每当发现有用户连接的时候就需要启动一个线程（线程池管理）</span><br><span class="line">        int keySelect = 0; // 接收轮询状态</span><br><span class="line">        while((keySelect = selector.select()) &gt; 0) &#123;    // 实现了轮询处理</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys() ;   // 获取全部的Key</span><br><span class="line">            Iterator&lt;SelectionKey&gt; selectionIter = selectionKeys.iterator() ;</span><br><span class="line">            while(selectionIter.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = selectionIter.next() ;  // 获取每一个Key的信息</span><br><span class="line">                if (selectionKey.isAcceptable()) &#123;  // 为连接模式</span><br><span class="line">                    SocketChannel clientChannel = serverSocketChannel.accept() ; // 等待连接</span><br><span class="line">                    if (clientChannel != null) &#123;</span><br><span class="line">                        executorService.submit(new EchoClientHandler(clientChannel)) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                selectionIter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.mldn.nio.client;</span><br><span class="line"></span><br><span class="line">import com.mldn.info.HostInfo;</span><br><span class="line">import com.mldn.util.inputUtil;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: ZhangYang</span><br><span class="line"> * @Date: 2019/4/10 15:45</span><br><span class="line"> */</span><br><span class="line">public class NIOEchoClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        SocketChannel clientChannel = SocketChannel.open() ; // 打开客户端连接通道</span><br><span class="line">        clientChannel.connect(new InetSocketAddress(HostInfo.HOST_NAME,HostInfo.PORT)) ;// 连接</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(50) ;// 开辟缓冲区</span><br><span class="line">        boolean flag = true ;</span><br><span class="line">        while(flag) &#123;</span><br><span class="line">            buffer.clear() ; // 清空缓冲区</span><br><span class="line">            String inputData = inputUtil.getString(&quot;请输入要发送的信息：&quot;).trim() ;</span><br><span class="line">            buffer.put(inputData.getBytes()) ; // 将输入的数据保存在缓冲区之中</span><br><span class="line">            buffer.flip() ; // 重置缓冲区</span><br><span class="line">            clientChannel.write(buffer) ; // 发送数据</span><br><span class="line">            buffer.clear() ; // 在读取之前进行缓冲区清空</span><br><span class="line">            int readCount = clientChannel.read(buffer) ;</span><br><span class="line">            buffer.flip() ;</span><br><span class="line">            System.err.println(new String(buffer.array(),0,readCount));</span><br><span class="line">            if(&quot;byebye&quot;.equalsIgnoreCase(inputData)) &#123;</span><br><span class="line">                flag = false ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clientChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a><strong>AIO</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">package com.mldn.aio.server;</span><br><span class="line"></span><br><span class="line">import com.mldn.info.HostInfo;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">class EchoHandler implements CompletionHandler&lt;Integer,ByteBuffer&gt; &#123;</span><br><span class="line">    private AsynchronousSocketChannel clientChannel ;</span><br><span class="line">    // 是否结束交互过程，exit = true表示结束，exit = false表示继续</span><br><span class="line">    private boolean exit = false ;</span><br><span class="line">    public EchoHandler(AsynchronousSocketChannel clientChannel) &#123;</span><br><span class="line">        this.clientChannel = clientChannel ;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result, ByteBuffer buffer) &#123;</span><br><span class="line">        buffer.flip() ; // 读取之前需要执行重置处理</span><br><span class="line">        String readMessage = new String(buffer.array(),0,buffer.remaining()).trim() ;</span><br><span class="line">        String writeMessage = &quot;【ECHO】&quot; + readMessage ;  // 回应的数据信息</span><br><span class="line">        if (&quot;byebye&quot;.equalsIgnoreCase(readMessage)) &#123;</span><br><span class="line">            writeMessage = &quot;【EXIT】拜拜，下次再见！&quot; ;</span><br><span class="line">            this.exit = true ; // 结束后期的交互</span><br><span class="line">        &#125;</span><br><span class="line">        this.echoWrite(writeMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void echoWrite(String content) &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(100) ;</span><br><span class="line">        buffer.put(content.getBytes()) ;// 向缓存中保存数据</span><br><span class="line">        buffer.flip() ;</span><br><span class="line">        this.clientChannel.write(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void completed(Integer result, ByteBuffer buf) &#123;</span><br><span class="line">                System.out.println(buf.hasRemaining());</span><br><span class="line">                if (buf.hasRemaining()) &#123;   // 缓存中是否有数据</span><br><span class="line">                    EchoHandler.this.clientChannel.write(buffer,buffer,this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if(EchoHandler.this.exit == false) &#123;    // 还没有结束</span><br><span class="line">                        ByteBuffer readBuffer = ByteBuffer.allocate(100) ;</span><br><span class="line">                        EchoHandler.this.clientChannel.read(readBuffer,readBuffer,new EchoHandler(EchoHandler.this.clientChannel)) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    EchoHandler.this.clientChannel.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.clientChannel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 连接接收的回调处理操作</span><br><span class="line">class AcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel,AIOServerThread&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void completed(AsynchronousSocketChannel channel, AIOServerThread aioThread) &#123;</span><br><span class="line">        aioThread.getServerChannel().accept(aioThread,this) ; // 接收连接</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(100) ;</span><br><span class="line">        channel.read(buffer,buffer,new EchoHandler(channel)) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, AIOServerThread aioThread) &#123;</span><br><span class="line">        System.err.println(&quot;客户端连接创建失败....&quot;);</span><br><span class="line">        aioThread.getLatch().countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置一个单独的服务器的处理线程</span><br><span class="line">class AIOServerThread implements Runnable &#123;</span><br><span class="line">    private AsynchronousServerSocketChannel serverChannel = null; // 服务器通道</span><br><span class="line">    private CountDownLatch latch = null ; // 做一个同步处理操作</span><br><span class="line"></span><br><span class="line">    public AIOServerThread() throws Exception &#123;</span><br><span class="line">        this.latch = new CountDownLatch(1) ;// 等待线程数量为1</span><br><span class="line">        this.serverChannel = AsynchronousServerSocketChannel.open(); // 打开服务器的通道</span><br><span class="line">        this.serverChannel.bind(new InetSocketAddress(HostInfo.PORT)) ; // 绑定端口</span><br><span class="line">        System.out.println(&quot;服务器启动成功，监听端口为：&quot; + HostInfo.PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AsynchronousServerSocketChannel getServerChannel() &#123;</span><br><span class="line">        return serverChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CountDownLatch getLatch() &#123;</span><br><span class="line">        return latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        this.serverChannel.accept(this,new AcceptHandler()) ;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.latch.await(); // 线程等待</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AIOEchoServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new Thread(new AIOServerThread()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">package com.mldn.aio.client;</span><br><span class="line"></span><br><span class="line">import com.mldn.util.inputUtil;</span><br><span class="line">import com.mldn.info.HostInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">class ClientReadHandler implements CompletionHandler&lt;Integer,ByteBuffer&gt; &#123;</span><br><span class="line">    private AsynchronousSocketChannel clientChannel ;</span><br><span class="line">    private CountDownLatch latch ;</span><br><span class="line">    public ClientReadHandler(AsynchronousSocketChannel clientChannel,CountDownLatch latch) &#123;</span><br><span class="line">        this.clientChannel = clientChannel ;</span><br><span class="line">        this.latch = latch ;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result, ByteBuffer buffer) &#123;</span><br><span class="line">        buffer.flip() ;</span><br><span class="line">        String readMessage = new String(buffer.array(),0,buffer.remaining()) ;</span><br><span class="line">        System.out.println(readMessage); // 输出读取内容</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.clientChannel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        this.latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClientWriteHandler implements CompletionHandler&lt;Integer,ByteBuffer&gt; &#123;</span><br><span class="line">    private AsynchronousSocketChannel clientChannel ;</span><br><span class="line">    private CountDownLatch latch ;</span><br><span class="line">    public ClientWriteHandler(AsynchronousSocketChannel clientChannel,CountDownLatch latch) &#123;</span><br><span class="line">        this.clientChannel = clientChannel ;</span><br><span class="line">        this.latch = latch ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result, ByteBuffer buffer) &#123;</span><br><span class="line">        if(buffer.hasRemaining()) &#123;</span><br><span class="line">            this.clientChannel.write(buffer,buffer,this);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ByteBuffer readBuffer = ByteBuffer.allocate(100) ; // 读取服务端回应</span><br><span class="line">            this.clientChannel.read(readBuffer,readBuffer,new ClientReadHandler(this.clientChannel,this.latch)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.clientChannel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        this.latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AIOClientThread implements Runnable &#123;</span><br><span class="line">    private AsynchronousSocketChannel clientChannel;</span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    public AIOClientThread() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.clientChannel = AsynchronousSocketChannel.open();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        this.clientChannel.connect(new InetSocketAddress(HostInfo.HOST_NAME, HostInfo.PORT));</span><br><span class="line">        this.latch = new CountDownLatch(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.latch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean sendMessage(String msg) &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(100) ;</span><br><span class="line">        buffer.put(msg.getBytes()) ;</span><br><span class="line">        buffer.flip() ;</span><br><span class="line">        this.clientChannel.write(buffer,buffer,new ClientWriteHandler(this.clientChannel,this.latch));</span><br><span class="line">        if(&quot;byebye&quot;.equalsIgnoreCase(msg)) &#123;</span><br><span class="line">            return false ;</span><br><span class="line">        &#125;</span><br><span class="line">        return true ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AIOEchoClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AIOClientThread client = new AIOClientThread() ;</span><br><span class="line">        new Thread(client).start();</span><br><span class="line">        while(client.sendMessage(inputUtil.getString(&quot;请输入要发送的内容：&quot;))) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://img.027cgb.com/613363/%E5%8B%BF%E6%89%B0%E6%97%A7%E4%BA%BAHy%20-%20%E6%8A%96%E9%9F%B3%E9%98%BF%E6%82%A0%E6%82%A0-%E4%B8%80%E6%9B%B2%E7%9B%B8%E6%80%9D%EF%BC%88%E5%AE%8C%E6%95%B4SQ%E7%89%88%EF%BC%89.mp3"></li>
                    
                        <li title="1" data-url="https://isujin.com/wp-content/uploads/2016/01/%E8%A1%97%E9%81%93%E7%9A%84%E5%AF%82%E5%AF%9E.mp3?_=1"></li>
                    
                        <li title="2" data-url="http://img.027cgb.com/613363/%E6%9E%97%E4%BF%8A%E6%9D%B0%20-%20%E6%88%91%E6%80%80%E5%BF%B5%E7%9A%84%20(Live).mp3"></li>
                    
                        <li title="3" data-url="http://img.027cgb.com/613363/%E6%AF%9B%E4%B8%8D%E6%98%93%20-%20%E7%89%A7%E9%A9%AC%E5%9F%8E%E5%B8%82.mp3"></li>
                    
                        <li title="4" data-url="http://img.027cgb.com/613363/%E6%AF%9B%E4%B8%8D%E6%98%93%20-%20%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BA%BA%20(Live).mp3"></li>
                    
                        <li title="5" data-url="http://img.027cgb.com/613363/%E8%AE%B8%E5%B5%A9%20-%20%E6%9C%89%E4%BD%95%E4%B8%8D%E5%8F%AF.mp3"></li>
                    
                        <li title="6" data-url="http://img.027cgb.com/613363/%E6%9E%97%E4%BF%8A%E6%9D%B0%20-%20%E5%A5%B9%E8%AF%B4.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>