{"meta":{"title":"知人者智，自知者明。","subtitle":null,"description":null,"author":"ZhangYang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"Mybatis源码分析（一）","date":"2018-12-24T13:38:09.662Z","updated":"2018-12-24T14:37:02.108Z","comments":true,"path":"2018/12/24/Mybatis源码分析（一）/","link":"","permalink":"http://yoursite.com/2018/12/24/Mybatis源码分析（一）/","excerpt":"","text":"title: Mybatis源码分析（一）date: 2018-12-24 21:38:09tags: Mybatis源码分析（一)mp3:cover: 关于具体的框架的搭建就不往上贴了，不会的话看一下这个链接：https://www.cnblogs.com/fangjet/p/7639606.html Mybatis框架源码分析：//读取配置文件InputStream inputstream=Resources.getResourcesAsStream(“mybatis-config.xml”);//创建sqlSessionFactory对象SqlSessionFactory sqlsessionFactory=new SqlSessionFactoryBuilder() .build(inputStream);//创建SqlSession对象session=sqlsessionFactory.openSession();//操作session.insert(“insertStu”,student)//提交session.commit();session.close(); SqlSessionFactory sqlsessionFactory=new SqlSessionFactoryBuilder().build(inputStream);首先把MyBatis的配置文件封装成IO流的方式，再者就是创建sqlsessionFactory的过程，这里面采用了工厂模式来生成sqlsessionFactory的实例，用SqlSessionFactoryBuilder的build方法，build方法里面有一个自己的重载的过程，这是因为在这里可以改变Mybatis配置文件中的properties,environment等信息，真正在build方法里面实现的还是用XMLConfigBuilder的parse（）方法来实现对mybatis配置文件的一个解析，这个parse方法返回的configuration对象就有了配置文件的一些信息，这个configuration对象会作为build方法的一个参数，调用build方法其实就是新建了一个DefaultSqlSessionFactory对象，他是SqlSessionFactory的实现类，也就是说最后返回的就是DefaultSqlSessionFactory对象 session=sqlsessionFactory.openSession();由sqlsessionFactory这个工厂来创造sqlsession对象，返回的还是defaultSqlSession对象，这个对象里面有一些属性，比如dirty，autocommit，executor等一些属性 session.insert(“insertStu”,student) （insertStu是映射文件的id）这个方法里面可以帮我们找到三个问题的答案:1.mybatis是如何把insertStu与映射文件的id对应起来的？2.mybatis如何把数据绑定到sql语句中？3.mybatis如何输送sql语句？insert方法其实调用的是update方法，里面会传入上面的两个参数，当sqlsession对象在执行的时候，他要根据configuration对象的mapper映射的id找到当前执行的sql语句，同时通过对应关系把值赋值到对应的 sql语句中 ，下来就是执行器Executor进行sql语句的执行工作，这里面应该就是封装的一些jdbc的操作，来完成对数据库的交互工作，在这个操作之前，会有MapperStatement对象将赋值内容和sql占位符进行绑定的一个操作。 session.commit();这个里面的主要是通过sqlsession对象里面的dirty属性来决定数据库的事务提交的方式，具体就是当dirty属性为true时，就是当sql语句执行完毕后，事务可以进行提交，当dirty属性为false时，当sql语句执行完毕后，事务可以进行回滚 Mybatis标签解析：mybatis的sql语句的配置文件不能为空，其次就是有一个xml解析器会把配置文件里面的sql语句的参数先全部换为占位符，再把参数名放在一个list集合中，等到使用的时候，使用反射机制把list数组里面的值读取出来做赋值处理 Mybatis标签解析—-TypeHandle每当Mybatis设置参数到PreparedStatemnet或者从ResultSet 结果集中取得值时，就会使用TypeHandle对象来处理数据库类型与java类型之间的转换，一般来说，类型转换可以满足日常的需求，但我们也可以自定义一个类型转换器，比如说数据库的flag字段是int类型，到Java代码中必须转换为Boolean类型，这是就需要自定义类型转换器 （1）实体类 public class Dept { private Integer deptNo; private String dname; private String loc; private boolean flag;（2） 表中字段 略过。。。。（3） 开发自定义类型转换器 setParameter方法：在生成SQL语句时被调用 getResult： 查询结束之后，在将ResultSet数据行装换为实体类对象时 通知TypeHandler将当前数据行某个字段转换为何种类型 public class MyTypeHandler implements TypeHandler { public void setParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType) throws SQLException { if(parameter==null){// dept.flag=null insertsql flag设置0 ps.setInt(i, 0); return; } System.out.println(&quot;类型转换器开始工作&quot;); Boolean flag =(Boolean)parameter; if(flag==true){ ps.setInt(i, 1); }else{ ps.setInt(i, 0); } } public Object getResult(ResultSet rs, String columnName) throws SQLException { int flag=rs.getInt(columnName); Boolean myFlag=Boolean.FALSE; if(flag==1){ myFlag=Boolean.TRUE; } return myFlag; } public Object getResult(ResultSet rs, int columnIndex) throws SQLException { // TODO Auto-generated method stub return null; } public Object getResult(CallableStatement cs, int columnIndex) throws SQLException { // TODO Auto-generated method stub return null; } } （4） 在MyBatis核心配置文件注册自定义类型转换器 这样其实是一个全局生效的配置，无关哪个数据库，无关哪张表，主要有这两个字段的，都会走自定义的类型转换器（1） 在Mapper.xml文件中指定使用自定义类型转换器场合 &lt; resultMap type=”dept” id=”deptMap”&gt; &lt; result column=”flag” property=”flag” typeHandler=”com.kaikeba.util.MyTypeHandler”/ &gt; &lt; /resultMap &gt;（2） 在查询Statement中指定对应的ResultMap &lt; select id=”deptFind” resultType=”Dept” &gt; select * from dept &lt; /select&gt;这个意思就是说只有执行这个select语句的时候，才会发生类型的转换，相当于给定了类型转换的时机 Mybatis标签解析—-ObjectFactory 这个标签的作用就是说，当Mybatis查询完毕后，是要把查询后的ResultSet结果集转换为对应的实体对象的，而ObjectFacory是负责创建这个对象的假如有一种情况就是说实体类中有一个字段country但是数据库的表中没有这个字段这时候可以自定义一个ObjectFactory来实现这个需求，就是重新定义类实例创建的规则（1）自定义ObjectFactory工厂public class MyObjectFactory extends DefaultObjectFactory { @Override public Object create(Class type) {//重新定义Dept类实例对象创建规则，其他类实例对象创建规则不想改变 if(Dept.class == type){ //依靠父类提供create方法创建Dept实例对象 Dept dept=(Dept) super.create(type); //设置自定义规则 dept.setCountry(&quot;China&quot;); return dept; } return super.create(type); } }（2） 在MyBatis核心文件中注册自定义工厂&lt; objectFactory type=”com.kaikeba.util.MyObjectFactory”&gt; &lt; /objectFactory&gt; Mybatis解析—plugins拦截器 拦截器的一个作用就是我们可以拦截某些方法的调用，我们可以选择在这些被拦截的方法执行前后加上某些逻辑，也可以在执行这些被拦截的方法时执行自己的逻辑而不再执行被拦截的方法。Mybatis拦截器设计的一个初衷就是为了供用户在某些时候可以实现自己的逻辑而不必去动Mybatis固有的逻辑。打个比方，对于Executor，Mybatis中有几种实现：BatchExecutor、ReuseExecutor、SimpleExecutor和CachingExecutor。这个时候如果你觉得这几种实现对于Executor接口的query方法都不能满足你的要求，那怎么办呢？是要去改源码吗？当然不。我们可以建立一个Mybatis拦截器用于拦截Executor接口的query方法，在拦截之后实现自己的query方法逻辑，之后可以选择是否继续执行原来的query方法。 对于拦截器Mybatis为我们提供了一个Interceptor接口，通过实现该接口就可以定义我们自己的拦截器。我们先来看一下这个接口的定义： 我们可以看到在该接口中一共定义有三个方法，intercept、plugin和setProperties。plugin方法是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。当返回的是代理的时候我们可以对其中的方法进行拦截来调用intercept方法，当然也可以调用其他方法，这点将在后文讲解。setProperties方法是用于在Mybatis配置文件中指定一些属性的。 定义自己的Interceptor最重要的是要实现plugin方法和intercept方法，在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象。而intercept方法就是要进行拦截的时候要执行的方法。 对于plugin方法而言，其实Mybatis已经为我们提供了一个实现。Mybatis中有一个叫做Plugin的类，里面有一个静态方法wrap(Object target,Interceptor interceptor)，通过该方法可以决定要返回的对象是目标对象还是对应的代理。 对于实现自己的Interceptor而言有两个很重要的注解，一个是@Intercepts，其值是一个@Signature数组。@Intercepts用于表明当前的对象是一个Interceptor，而@Signature则表明要拦截的接口、方法以及对应的参数类型。来看一个自定义的简单Interceptor： import java.util.Properties;import org.apache.ibatis.executor.Executor;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.plugin.Interceptor;import org.apache.ibatis.plugin.Intercepts;import org.apache.ibatis.plugin.Invocation;import org.apache.ibatis.plugin.Plugin;import org.apache.ibatis.plugin.Signature;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds;@Intercepts( { @Signature( method=”query”, type=Executor.class, args={MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class} ) } )public class SimpleInterceptor implements Interceptor { /* * * 参数：Invocation{ 代理对象 ，被监控方法对象 ，当前被监控方法运行时需要实参} * **/ public Object intercept(Invocation invocation) throws Throwable { System.out.println(&quot;被拦截方法执行之前，做的辅助服务.....&quot;); Object object=invocation.proceed();//执行被拦截方法 System.out.println(&quot;被拦截方法执行之后，做的辅助服务.....&quot;); return object; } /* * * 参数： target 表示被拦截对象,应该Executor接口实例对象 * 作用： * 如果被拦截对象所在的类有实现接口 * 就为当前拦截对象生成一个【$Proxy】 * * 如果被拦截对象所在的类没有指定接口 * 这个对象之后行为就不会被代理操作 * * */ public Object plugin(Object target) { return Plugin.wrap(target, this); } public void setProperties(Properties properties) { // TODO Auto-generated method stub } }然后在MyBatis核心配置文件注册自定义拦截器&lt; plugins&gt; &lt; plugin interceptor=”com.kaikeba.util.SimpleInterceptor”&gt; &lt; /plugins&gt; MyBatis自定义拦截器，可以拦截接口只有四种.Executor.class， StatementHandler.class（生成一个preparement对象，并把sql语句放到preparement里面）ParameterHandler.class,（参数处理器主要是把传入的参数对象填充到sql映射文件的标签里面）ResultSetHandler.class（当Mybatis进行查询的时候，进行当前数据行里面的值和对象的哪一个参数进行匹配的工作）","categories":[],"tags":[]},{"title":"秋招实习感悟","slug":"秋招实习感悟","date":"2018-12-24T07:05:46.000Z","updated":"2018-12-24T07:15:32.218Z","comments":true,"path":"2018/12/24/秋招实习感悟/","link":"","permalink":"http://yoursite.com/2018/12/24/秋招实习感悟/","excerpt":"","text":"陆陆续续找实习一个月，很累，现在看来互联网这个行业面试真的是玄学，我不比别人学的差，为什么别人能找到实习就我不能，我感觉不公平，深深感觉到了不公平，一个组的人，自己推掉自己的课去给帮别人面试准备，结果别人都找到实习了，就我没有，不知道是命运的不公还是自己运气真的不好，为什么我自我感觉自己是这么好的人却没有一个好结果，不公平，有时候命运真的不公平，如果我输给了实力，我认了，毕竟技不如人，但是我输给了运气，这个结果我接受不了，我不信命，也不认命，只要我觉得对的事情我就会一直干下去，没有人能阻拦我，不管这个事情对还是错，我认定的事我自己一定会坚持，总有一天，也许就在3个月后的春招，我会赎回我的一切，我要凭借自己，自己的固执，自己的执着赢得一切，我是一个自尊心很强的人，但这并不代表我经受不起打击，相信自己，等我觉得赢回我自己认为的欠下的东西的时候，我会亲自来这里删掉这里曾经许下的诺言。 ------------------------------共勉","categories":[],"tags":[{"name":"秋招实习之路","slug":"秋招实习之路","permalink":"http://yoursite.com/tags/秋招实习之路/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-24T01:30:00.616Z","updated":"2018-12-24T01:30:00.617Z","comments":true,"path":"2018/12/24/hello-world/","link":"","permalink":"http://yoursite.com/2018/12/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}