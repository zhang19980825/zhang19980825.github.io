{"meta":{"title":"知足常乐。","subtitle":null,"description":null,"author":"ZhangYang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Mybatis源码分析（三）","slug":"Mybatis源码分析（三）","date":"2018-12-26T14:11:41.000Z","updated":"2018-12-26T14:14:56.913Z","comments":true,"path":"2018/12/26/Mybatis源码分析（三）/","link":"","permalink":"http://yoursite.com/2018/12/26/Mybatis源码分析（三）/","excerpt":"","text":"动态sql标签—-for eachfor each标签的主要参数：item index collection open seperator closeitem：表示集合中示每一个元素进行迭代时的别名index：表示集合中元素进行迭代时的位置collection：表示传入参数的类型open/close：表示以什么开始以什么结束sepeator：表示每次迭代之间以什么作为分割符下面举几个例子：Mybatis的级联操作：一般来说只会使用级联查询，其他的如级联删除等维护的成本较大，一般不会使用级联查询—一对多查询（部门和职员之间的一对多的关系 在部门的实体类中声明list类型的数组，里面是职员类型的对象，有两种方式） 级联查询–多对一查询（根据职员的编号查询员工的基本信息和部门的基本信息，员工的实体类型中有一个部门类型的参数）","categories":[],"tags":[{"name":"Mybatis源码分析（三）","slug":"Mybatis源码分析（三）","permalink":"http://yoursite.com/tags/Mybatis源码分析（三）/"}]},{"title":"Mybatis源码分析（二）","slug":"Mybatis源码分析（二）","date":"2018-12-25T12:42:54.000Z","updated":"2018-12-26T14:57:41.996Z","comments":true,"path":"2018/12/25/Mybatis源码分析（二）/","link":"","permalink":"http://yoursite.com/2018/12/25/Mybatis源码分析（二）/","excerpt":"","text":"由于Mybatis和Spring框架中都大量使用了代理模式，所以先讲一下代理模式，据我所知，代理模式一般有两种实现，一种是通过组合的方式来实现代理模式这种实现方式比较简单，可以看看菜鸟教程的代理模式：http://www.runoob.com/design-pattern/proxy-pattern.html， 但是在框架中都不会使用这种方式来实现代理，一般是使用java的反射机制来实现的，比如说Mybatis的封装jdbc的操作就是用jdk的动态代理来实现的代理模式：1.作用：将主要业务和次要业务进行松耦合的处理 2.JDK代理模式实现 1 接口角色： 定义所有需要被监听行为 2.接口实现类：中国人，印度人 3.通知类： 1）次要业务进行具体实现 2）通知JVM,当前被拦截的主要业务方法与次要业务方法应该如何绑定执行 4.监控对象（代理对象） 1） 被监控实例对象 2） 需要被监控监控行为 3）具体通知类实例对象Mybatis中Mapper配置文件详解1.#{}的参数问题 #{}实现的是向prepareStatement中的预处理语句中设置参数值，sql语句中#{}表示一个占位符即 ？ 使用#{参数名},将参数的内容添加到sql语句中指定位置. 如果当前sql语句中只有一个参数,此时参数名称可以随意定义 但是,如果当前sql语句有多个参数,此时参数名称应该是与当前表关联[实体类的属性名]或则[Map集合关键字] 可以采用一下两种方式来对sql语句进行参数的赋值操作 2.#和$的区别其实#就是起一个占位符的作用，就是？，而$符号则是采用直接赋值的方式，简单来说如果使用#{}，会将{}里面的传入的值自动解析成为带引号的值，如果使用$就不会带引号，举个例子在登录的时候有一条查询语句，写了一个错误的用户名，用$符号进行解析的时候就是select from test where username=’张三’ or ‘1’=’1’ and password=’13’;但是用#解析的时候就会加上引号，就可以防止sql注入，大多数情况下我们都会使用#符号的方式来避免sql注入，但是在一些特殊情况就会使用到$符号:比如说现在有两张数据库表，在一条sql语句中要对数据库的表名进行动态的改变，这时候必须用$符号 还有就是说动态的指定查询语句中的排序字段时，必须使用$ select from dept order by ${name}3.Mybatis–Mapper映射文件之resultMap先说一下resultType吧，就是说如果sql映射文件的返回的结果集刚好是我们定义的实体类对象，这个时候就用resultType，但是当实体类的参数和数据库中的字段不一样时，java通过反射机制进行赋值的时候就会出错，这个时候就要运用resultMap把数据库的字段和实体类的参数进行一一对应1）ResultMap中的constructor标签（这个不是很重要，可以选择性忽略）作用：有可能存在一种情况就是说实体类有一个参数是数据库对应表中的字段所没有的，这个时候可以通过构造函数算出这个实体类的参数的值，代码如下 配置文件如下： ###如果说数据库中的字段是tb_name话，Mybatis会把横杠去掉并把后面的第一个字母变为大写，就是tbName再去实体类中进行匹配4.Mybatis动态sqlif：根据if标签里面的条件是否为真来决定标签里面的内容是否可以到sql语句中choose when othenwise —-分支选择条件where： 1.如果where标签内部所有的判断都不成立。在查询语句中是不会出现where或则只出现 where1=1 2.where标签中，将第一个满足条件的语句中前部包含【and ,or】自动取消set:一般用于更新语句中动态指定需要更新字段信息，往往需要与if标签使用，自动将最后一个更新字段后面“，”取消trim:自定义第一个满足条件前部的代替内容也可以自定义最后一个满足条件后面的代替内容","categories":[],"tags":[{"name":"Mybatis源码分析（二）","slug":"Mybatis源码分析（二）","permalink":"http://yoursite.com/tags/Mybatis源码分析（二）/"}]},{"title":"Mybatis源码分析（一）","slug":"Mybatis源码分析（一）","date":"2018-12-25T03:37:49.000Z","updated":"2018-12-26T14:51:44.291Z","comments":true,"path":"2018/12/25/Mybatis源码分析（一）/","link":"","permalink":"http://yoursite.com/2018/12/25/Mybatis源码分析（一）/","excerpt":"","text":"关于具体的框架的搭建就不往上贴了，不会的话看一下这个链接：https://www.cnblogs.com/fangjet/p/7639606.html Mybatis框架源码分析：//读取配置文件InputStream inputstream=Resources.getResourcesAsStream(“mybatis-config.xml”);//创建sqlSessionFactory对象SqlSessionFactory sqlsessionFactory=new SqlSessionFactoryBuilder() .build(inputStream);//创建SqlSession对象session=sqlsessionFactory.openSession();//操作session.insert(“insertStu”,student)//提交session.commit();session.close(); SqlSessionFactory sqlsessionFactory=new SqlSessionFactoryBuilder().build(inputStream);首先把MyBatis的配置文件封装成IO流的方式，再者就是创建sqlsessionFactory的过程，这里面采用了工厂模式来生成sqlsessionFactory的实例，用SqlSessionFactoryBuilder的build方法，build方法里面有一个自己的重载的过程，这是因为在这里可以改变Mybatis配置文件中的properties,environment等信息，真正在build方法里面实现的还是用XMLConfigBuilder的parse（）方法来实现对mybatis配置文件的一个解析，这个parse方法返回的configuration对象就有了配置文件的一些信息，这个configuration对象会作为build方法的一个参数，调用build方法其实就是新建了一个DefaultSqlSessionFactory对象，他是SqlSessionFactory的实现类，也就是说最后返回的就是DefaultSqlSessionFactory对象 session=sqlsessionFactory.openSession();由sqlsessionFactory这个工厂来创造sqlsession对象，返回的还是defaultSqlSession对象，这个对象里面有一些属性，比如dirty，autocommit，executor等一些属性 session.insert(“insertStu”,student) （insertStu是映射文件的id）这个方法里面可以帮我们找到三个问题的答案:1.mybatis是如何把insertStu与映射文件的id对应起来的？2.mybatis如何把数据绑定到sql语句中？3.mybatis如何输送sql语句？insert方法其实调用的是update方法，里面会传入上面的两个参数，当sqlsession对象在执行的时候，他要根据configuration对象的mapper映射的id找到当前执行的sql语句，同时通过对应关系把值赋值到对应的 sql语句中 ，下来就是执行器Executor进行sql语句的执行工作，这里面应该就是封装的一些jdbc的操作，来完成对数据库的交互工作，在这个操作之前，会有MapperStatement对象将赋值内容和sql占位符进行绑定的一个操作。 session.commit();这个里面的主要是通过sqlsession对象里面的dirty属性来决定数据库的事务提交的方式，具体就是当dirty属性为true时，就是当sql语句执行完毕后，事务可以进行提交，当dirty属性为false时，当sql语句执行完毕后，事务可以进行回滚 Mybatis标签解析：mybatis的sql语句的配置文件不能为空，其次就是有一个xml解析器会把配置文件里面的sql语句的参数先全部换为占位符，再把参数名放在一个list集合中，等到使用的时候，使用反射机制把list数组里面的值读取出来做赋值处理 Mybatis标签解析—-TypeHandle 每当Mybatis设置参数到PreparedStatemnet或者从ResultSet 结果集中取得值时，就会使用TypeHandle对象来处理数据库类型与java类型之间的转换，一般来说，类型转换可以满足日常的需求，但我们也可以自定义一个类型转换器，比如说数据库的flag字段是int类型，到Java代码中必须转换为Boolean类型，这是就需要自定义类型转换器 （1）实体类 （2） 表中字段 （3） 开发自定义类型转换器 （4） 在MyBatis核心配置文件注册自定义类型转换器 这样其实是一个全局生效的配置，无关哪个数据库，无关哪张表，主要有这两个字段的，都会走自定义的类型转换器（1） 在Mapper.xml文件中指定使用自定义类型转换器场合 （2） 在查询Statement中指定对应的ResultMap 这个意思就是说只有执行这个select语句的时候，才会发生类型的转换，相当于给定了类型转换的时机 Mybatis标签解析—-ObjectFactory 这个标签的作用就是说，当Mybatis查询完毕后，是要把查询后的ResultSet结果集转换为对应的实体对象的，而ObjectFacory是负责创建这个对象的假如有一种情况就是说实体类中有一个字段country但是数据库的表中没有这个字段这时候可以自定义一个ObjectFactory来实现这个需求，就是重新定义类实例创建的规则（1）自定义ObjectFactory工厂 （2） 在MyBatis核心文件中注册自定义工厂 Mybatis解析—plugins拦截器 拦截器的一个作用就是我们可以拦截某些方法的调用，我们可以选择在这些被拦截的方法执行前后加上某些逻辑，也可以在执行这些被拦截的方法时执行自己的逻辑而不再执行被拦截的方法。Mybatis拦截器设计的一个初衷就是为了供用户在某些时候可以实现自己的逻辑而不必去动Mybatis固有的逻辑。打个比方，对于Executor，Mybatis中有几种实现：BatchExecutor、ReuseExecutor、SimpleExecutor和CachingExecutor。这个时候如果你觉得这几种实现对于Executor接口的query方法都不能满足你的要求，那怎么办呢？是要去改源码吗？当然不。我们可以建立一个Mybatis拦截器用于拦截Executor接口的query方法，在拦截之后实现自己的query方法逻辑，之后可以选择是否继续执行原来的query方法。 对于拦截器Mybatis为我们提供了一个Interceptor接口，通过实现该接口就可以定义我们自己的拦截器。我们先来看一下这个接口的定义： 我们可以看到在该接口中一共定义有三个方法，intercept、plugin和setProperties。plugin方法是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。当返回的是代理的时候我们可以对其中的方法进行拦截来调用intercept方法，当然也可以调用其他方法，这点将在后文讲解。setProperties方法是用于在Mybatis配置文件中指定一些属性的。 定义自己的Interceptor最重要的是要实现plugin方法和intercept方法，在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象。而intercept方法就是要进行拦截的时候要执行的方法。 对于plugin方法而言，其实Mybatis已经为我们提供了一个实现。Mybatis中有一个叫做Plugin的类，里面有一个静态方法wrap(Object target,Interceptor interceptor)，通过该方法可以决定要返回的对象是目标对象还是对应的代理。 对于实现自己的Interceptor而言有两个很重要的注解，一个是@Intercepts，其值是一个@Signature数组。@Intercepts用于表明当前的对象是一个Interceptor，而@Signature则表明要拦截的接口、方法以及对应的参数类型。来看一个自定义的简单Interceptor： 然后在MyBatis核心配置文件注册自定义拦截器 MyBatis自定义拦截器，可以拦截接口只有四种.Executor.class， StatementHandler.class（生成一个preparement对象，并把sql语句放到preparement里面）ParameterHandler.class,（参数处理器主要是把传入的参数对象填充到sql映射文件的标签里面）ResultSetHandler.class（当Mybatis进行查询的时候，进行当前数据行里面的值和对象的哪一个参数进行匹配的工作）","categories":[],"tags":[{"name":"Mybatis源码分析（一）","slug":"Mybatis源码分析（一）","permalink":"http://yoursite.com/tags/Mybatis源码分析（一）/"}]},{"title":"秋招实习感悟","slug":"秋招实习感悟","date":"2018-12-24T07:05:46.000Z","updated":"2018-12-26T14:52:29.644Z","comments":true,"path":"2018/12/24/秋招实习感悟/","link":"","permalink":"http://yoursite.com/2018/12/24/秋招实习感悟/","excerpt":"","text":"陆陆续续找实习一个月，很累，现在看来互联网这个行业面试真的是玄学，我不比别人学的差，为什么别人能找到实习就我不能，我感觉不公平，深深感觉到了不公平，一个组的人，自己推掉自己的课去给帮别人面试准备，结果别人都找到实习了，就我没有，不知道是命运的不公还是自己运气真的不好，为什么我自我感觉自己是这么好的人却没有一个好结果，不公平，有时候命运真的不公平，如果我输给了实力，我认了，毕竟技不如人，但是我输给了运气，这个结果我接受不了，我不信命，也不认命，只要我觉得对的事情我就会一直干下去，没有人能阻拦我，不管这个事情对还是错，我认定的事我自己一定会坚持，总有一天，也许就在3个月后的春招，我会赎回我的一切，我要凭借自己，自己的固执，自己的执着赢得一切，我是一个自尊心很强的人，但这并不代表我经受不起打击，相信自己，等我觉得赢回我自己认为的欠下的东西的时候，我会亲自来这里删掉这里曾经许下的诺言。 ------------------------------共勉","categories":[],"tags":[{"name":"秋招实习之路","slug":"秋招实习之路","permalink":"http://yoursite.com/tags/秋招实习之路/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-24T01:30:00.616Z","updated":"2018-12-24T01:30:00.617Z","comments":true,"path":"2018/12/24/hello-world/","link":"","permalink":"http://yoursite.com/2018/12/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}