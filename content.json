{"meta":{"title":"知足常乐。","subtitle":null,"description":null,"author":"ZhangYang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"SpringMVC学习（第一次）","slug":"SpringMVC学习（第一次）","date":"2019-01-08T06:23:02.000Z","updated":"2019-01-09T07:05:40.347Z","comments":true,"path":"2019/01/08/SpringMVC学习（第一次）/","link":"","permalink":"http://yoursite.com/2019/01/08/SpringMVC学习（第一次）/","excerpt":"","text":"三层架构介绍表现层： 也就是我们常说的web 层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http 协议请求web 层，web 需要接收 http 请求，完成 http 响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） 业务层： 也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性（也就是我们说的， 事务应该放到业务层来控制） 持久层： 也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的 MVC设计模式MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写， 是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：Model（模型）：模型包含业务模型和数据模型，数据模型用于封装数据，业务模型用于处理业务。View（视图）：通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。通常视图是依据模型数据创建的。Controller（控制器）：是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。 SpringMVC介绍SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring 的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful 编程风格的请求。 SpringMVC流程分析1、用户发送请求至前端控制器DispatcherServlet2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器5、HandlerAdapter执行处理器(handler，也叫后端控制器)。6、Controller执行完成返回ModelAndView7、HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器9、ViewReslover解析后返回具体View对象10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。11、DispatcherServlet响应用户 SpringMVC组件DispatcherServlet：前端控制器用户请求到达前端控制器，它就相当于mvc模式中的C，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。HandlerMapping：处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。Handler：处理器Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。HandlAdapter：处理器适配器通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。View Resolver：视图解析器View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。View：视图springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。（一般来说需要开发的就是处理器和视图，其中处理器映射器，处理器适配器，视图解析器成为SpringMVC的三大组件）三大组件的配置：RequestMappingHandlerMapping：注解式处理器映射器对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 RequestMappingHandlerAdapter：注解式处理器适配器对标记@ResquestMapping的方法进行适配。1234&lt;!--注解映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; 或者通过mvc的标签和配置&lt;mvc:annotation-drivern /&gt;，这个标签会向Spring的容器中注入很多的BeanDefinition其中包含上面的注解映射器和注解适配器 视图解析器的配置：1234567&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 该视图解析器，默认的视图类就是JstlView，可以不写 --&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; SSM框架的整合由于整合过Spring和Mybatis，所以只贴出Springmvc.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 处理器类的扫描 --&gt; &lt;context:component-scan base-package=&quot;com.kkb.ssm.controller&quot; /&gt; &lt;!-- 配置注解的适配器和映射器，同时还注入了很多其他的bean --&gt; &lt;!-- 处理器适配器会去调用conversion-service --&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; /&gt; &lt;!-- 显式的配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置自定义的转换服务 --&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;!-- 自定义日期类型转换器 --&gt; &lt;bean class=&quot;com.kkb.ssm.controller.converter.DateConverter&quot;&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置异常处理器 --&gt; &lt;bean class=&quot;com.kkb.ssm.exception.resolver.CustomExceptionResolver&quot;&gt;&lt;/bean&gt; &lt;!-- 配置多部件解析器 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 限制上传文件的大小 单位是byte--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 里面就是多配了日期转换器和部件解析器 Controller方法的返回值一般来说都返回一个字符串：rediect和forward的区别：redirect:相当于“response.sendRedirect()”浏览器URL发生改变Request域不能共享forward：相当于“request.getRequestDispatcher().forward(request,response)”浏览器URL不发送改变Request域可以共享比较常用的是使用注解来修饰:@ResponseBody和@RequestBodyResponseBody注解可以通过内置的9种HttpMessageConverter，匹配不同的Controller返回值类型，然后进行不同的消息转换处理。 @RequestBody注解的作用和@ResponseBody注解正好相反，它是处理请求参数的Http消息转换的。 请求参数绑定1.简单类型参数绑定方式直接绑定：需要保证http请求的key和Controller方法中的参数保持一致注解绑定：为了解决key和参数不一致的情况需要使用@RequestParam注解才能将请求参数绑定成功。2.POJO类型的参数绑定控制器方法的参数类型是 POJO 类型。要求表单中参数名称和 POJO 类的属性名称保持一致。3.绑定包装POJO包装POJO类，依然是一个POJO，只是说为了方便沟通，将POJO中包含另一个POJO的这种类，称之为包装POJO。4.POJO类型集合或者数组接收参数批量传递的请求参数，最终要使用List来接收，那么这个List必须放在另一个POJO类中。就可以用这个请求： http://localhost:8080/xxx/batchUpdateItem?itemList[0].id=1&amp; itemList[0].name=iphone&amp; itemList[0].price=1000&amp;itemList[1].id=2&amp; itemList[1]. name=iphone x&amp; itemList[1].price=2000","categories":[],"tags":[]},{"title":"Spring-Mybatis整合","slug":"Spring-Mybatis整合","date":"2019-01-05T17:24:48.000Z","updated":"2019-01-09T07:37:53.285Z","comments":true,"path":"2019/01/06/Spring-Mybatis整合/","link":"","permalink":"http://yoursite.com/2019/01/06/Spring-Mybatis整合/","excerpt":"","text":"整合思路Spring在java项目中，主要的责任就是对javaBean进行IoC处理（spring容器）三层结构：业务层、持久层 持久层：DataSource、SqlSessionFactory（单例管理）、MapperScannerConfigurer 业务层：Service实现类、事务管理三层架构最主要的东西还是配置文件的编写： 和数据库交互的配置文件applicationContext-dao.xml:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 读取java配置文件，替换占位符数据 --&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;db.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置SqlSessionFactory --&gt;&lt;bean id=&quot;sqlSessionFactory&quot;class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;&lt;!-- 注入dataSource --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;!-- mybatis批量别名配置 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.kkb.ms.po&quot;&gt;&lt;/property&gt; &lt;!-- 注入mybatis的全局配置文件路径 (该部分可以被省略掉) --&gt; &lt;!-- &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot;&gt;&lt;/property&gt; --&gt;&lt;/bean&gt; &lt;!-- 相当于配置之前的AccountDao持久层bean --&gt; &lt;!-- 配置Mapper代理对象方式一：MapperFactoryBean --&gt; &lt;!-- 通过MapperFactoryBean生成的代理对象，一次只能针对一个接口进行生成 --&gt; &lt;!-- 注意事项：mapper接口类和mapper映射文件同包同名 --&gt; &lt;!-- &lt;bean id=&quot;accountMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; 注入SqlSessionFactory &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; 注入目标接口类 &lt;property name=&quot;mapperInterface&quot; value=&quot;com.kkb.ms.mapper.AccountMapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置Mapper代理对象方式二：MapperScannerConfigurer --&gt; &lt;!-- 批量代理对象的生成 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 指定需要生成代理的接口所在的包名 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.kkb.ms.mapper&quot;&gt;&lt;/property&gt; &lt;!-- 注意事项：不要配置SqlSessionFactory --&gt; &lt;!-- &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; applicationContext-services.xml:123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kkb.ms.mapper.AccountMapper&quot;&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;queryMoney&quot; parameterType=&quot;string&quot; resultType=&quot;double&quot;&gt; SELECT money FROM testms WHERE name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;map&quot;&gt; UPDATE testms SET money = #&#123;money&#125; WHERE name = #&#123;name&#125; &lt;/update&gt;&lt;/mapper&gt; applicationContext-services.xml: (事务处理)123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 配置平台事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务通知 --&gt;&lt;!-- tx:advice：对应的处理器类就是TransactionInterceptor类（实现了MethodInterceptor） --&gt;&lt;!-- TransactionInterceptor类实现事务是通过transaction-manager属性指定的值进行事务管理 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 设置事务管理信息 --&gt; &lt;tx:attributes&gt; &lt;!-- 增删改使用REQUIRED事务传播行为 --&gt; &lt;!-- 查询使用read-only --&gt; &lt;tx:method name=&quot;transfer*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 基于AspectJ + XML方式实现声明式事务 --&gt;&lt;aop:config&gt; &lt;!-- aop:advisor标签使用的是传统spring aop开发方式实现的 --&gt; &lt;!-- spring已经实现了该增强功能，spring使用的是实现MethodInterceptor接口的方式实现的 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;&lt;/aop:config&gt;w&lt;/beans&gt; Dao层：12345678910package com.kkb.ms.mapper;import org.apache.ibatis.annotations.Param;public interface AccountMapper &#123; void update(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;)double money); double queryMoney(String name);&#125; 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kkb.ms.mapper.AccountMapper&quot;&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;queryMoney&quot; parameterType=&quot;string&quot; resultType=&quot;double&quot;&gt; SELECT money FROM testms WHERE name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;map&quot;&gt; UPDATE testms SET money = #&#123;money&#125; WHERE name = #&#123;name&#125; &lt;/update&gt;&lt;/mapper&gt; Services层（实现转账的业务）123456package com.kkb.ms.service;public interface AccountService &#123; void transfer(String from , String to,double money);&#125; 1234567891011121314151617181920212223242526package com.kkb.ms.test;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.kkb.ms.service.AccountService;@RunWith(SpringJUnit4ClassRunner.class)//@ContextConfiguration(locations = &#123; &quot;classpath:spring/applicationContext-dao.xml&quot;, &quot;classpath:spring/applicationContext-service.xml&quot;,// &quot;classpath:spring/applicationContext-tx.xml&quot; &#125;)@ContextConfiguration(locations = &quot;classpath:spring/applicationContext-*.xml&quot; )public class AccountServiceTest &#123; @Resource private AccountService service; @Test public void testTransfer() &#123; service.transfer(&quot;老公&quot;, &quot;老婆&quot;, 100); &#125;&#125;","categories":[],"tags":[{"name":"Spring-Mybatis整合","slug":"Spring-Mybatis整合","permalink":"http://yoursite.com/tags/Spring-Mybatis整合/"}]},{"title":"Spring组件学习","slug":"Spring组件学习","date":"2019-01-05T09:24:35.000Z","updated":"2019-01-09T07:39:31.975Z","comments":true,"path":"2019/01/05/Spring组件学习/","link":"","permalink":"http://yoursite.com/2019/01/05/Spring组件学习/","excerpt":"","text":"Spring组件学习一.Spring应用之SpringJdbc实现：1.引入相关的jar包12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2.对Spring配置文件进行Spring的配置（数据库连接池写了两种一种是内置的数据库连接池一种是DBCP连接池）12345678910111213141516171819202122232425&lt;!-- 管理spring内置的DataSource --&gt; &lt;!-- &lt;bean id=&quot;dataSource&quot; --&gt; &lt;!-- class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; --&gt; &lt;!-- set方法注入属性，和类中的成员属性无关，和set方法名称有关，比如有个属性叫username，但是set方法：setName --&gt; &lt;!-- &lt;property name=&quot;driverClassName&quot; --&gt; &lt;!-- value=&quot;com.mysql.jdbc.Driver&quot; /&gt; --&gt; &lt;!-- &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///kkb&quot; /&gt; --&gt; &lt;!-- &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; --&gt; &lt;!-- &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; --&gt; &lt;!-- &lt;/bean&gt; --&gt; &lt;!-- 管理第三方的DataSource --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;&lt;!-- set方法注入属性，和类中的成员属性无关，和set方法名称有关，比如有个属性叫username，但是set方法：setName --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/jdbctest?useUnicode=true&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;19980825&quot; /&gt;&lt;/bean&gt;&lt;!-- 管理JdbcTemplate --&gt;&lt;bean id=&quot;template&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 3.用Spring整合Junit的方式进行测试12345678910111213141516171819202122232425262728293031323334@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:spring.xml&quot;)public class TestJdbcTemplate2 &#123; @Autowired private JdbcTemplate jdbcTemplate; @Test public void test() &#123; // 完成数据的添加 //jdbcTemplate.update(&quot;insert into blog values(6,&quot;学习&quot;,&quot;张红&quot;,7,2019-1-3)&quot;); &#125; @Test public void test2() &#123; // 第一个参数：要执行的SQL语句 // 第二个参数：结果映射处理器（RowMapper） // 第三个参数：SQL语句中的入参 List&lt;Account&gt; aList = jdbcTemplate.query(&quot;SELECT * FROM account&quot;, new MyBeanMapper(), null); System.out.println(aList); &#125;&#125;/** * 结果映射器 * @author think * */class MyBeanMapper implements RowMapper &#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(&quot;id&quot;)); account.setName(rs.getString(&quot;name&quot;)); account.setMoney(rs.getDouble(&quot;money&quot;)); return account; &#125;&#125; 二.Spring应用之SpringJdbcDaoSupportJdbcDaoSupport是JDBC数据访问对象的超类。它与特定的数据源相关联。Spring Inversion of Control （IOC）容器或BeanFactory负责获得相应数据源的配置详细信息，并将其与JdbcDaoSupport相关联。这个类最重要的功能就是使子类可以使用JdbcTemplate对象。SpringJdbcDaoSupport就是里面内置了JdbcTemplate对象，我们只需要在dao层继承这个SpringJdbcDaoSupport 但是在配置文件中必须对JdbcTemple进行管理1.引入相关的jar包2.配置文件的相关配置123456789101112131415161718192021&lt;!-- 从底层往上层配置 --&gt;&lt;!-- 管理第三方的DataSource --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;&lt;!-- set方法注入属性，和类中的成员属性无关，和set方法名称有关，比如有个属性叫username，但是set方法：setName --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///kkb&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;&lt;/bean&gt;&lt;!-- 管理JdbcTemplate --&gt;&lt;bean id=&quot;template&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--配置 AccountDao 和AccountService --&gt;&lt;context:component-scan base-package=&quot;com.kkb.spring.service&quot;&gt;&lt;/context:component-scan&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.kkb.spring.dao.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 3.服务层（ServiceImpl）123456789101112131415161718192021222324//@Transactional：标记该类的所有方法都已经被事务进行管理了，至于管理属性，不设置的话，都采取默认值@Transactional@Servicepublic class AccountServiceImpl implements AccountService &#123; @Resource private AccountDao accountDao; @Override public void transfer(String from, String to, double money) &#123; // 先查询from账户的钱 double fromMoney = accountDao.queryMoney(from); // 对from账户进行扣钱操作 accountDao.update(from, fromMoney - money); //手动制造异常 System.out.println(1/0); // 先查询from账户的钱 double toMoney = accountDao.queryMoney(to); // 对to账户进行加钱操作 accountDao.update(to, toMoney + money); &#125;&#125; 4.Dao层123456789101112131415161718192021222324252627@Repositorypublic class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; // JDBC操作 // Mybatis操作 // JdbcTemplate操作 // @Resource // private JdbcTemplate jdbcTemplate; @Override public void update(String name, double money) &#123; Object[] args = &#123; money, name &#125;; // jdbcTemplate.update(&quot;UPDATE account SET money = ? WHERE name = ? &quot;, args); this.getJdbcTemplate().update(&quot;UPDATE account SET money = ? WHERE name = ? &quot;, args); &#125; @Override public double queryMoney(String name) &#123; // Double money = jdbcTemplate.queryForObject(&quot;SELECT money FROM account WHERE // name = ?&quot;, new DoubleMapper(), // name); Double money = this.getJdbcTemplate().queryForObject(&quot;SELECT money FROM account WHERE name = ?&quot;, new DoubleMapper(), name); return money; &#125;&#125; 三.Spring应用之Spring事务管理事务的特性（ACID）：原子性：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。一致性：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。隔离性：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。持久性：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 事务并发问题（隔离性导致）：在事务的并发操作中可能会出现一些问题：脏读：一个事务读取到另一个事务未提交的数据。不可重复读：一个事务因读取到另一个事务已提交的数据。导致对同一条记录读取两次以上的结果不一致。update操作幻读：一个事务因读取到另一个事务已提交的数据。导致对同一张表读取两次以上的结果不一致。insert、delete操作 四种隔离级别：现在来看看MySQL数据库为我们提供的四种隔离级别（由低到高）：①Read uncommitted (读未提交)：最低级别，任何情况都无法保证。②Read committed (读已提交)：可避免脏读的发生。③Repeatable read (可重复读)：可避免脏读、不可重复读的发生。④Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。大多数数据库的默认隔离级别是Read committed，比如Oracle、DB2等。MySQL数据库的默认隔离级别是Repeatable read。 Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。 PlatformTransactionManager接口 – 平台事务管理器.(真正管理事务的类)。该接口有具体的实现类，根据不同的持久层框架，需要选择不同的实现类！ TransactionDefinition接口 – 事务定义信息.(事务的隔离级别,传播行为,超时,只读)这个接口里面有两个重要的参数 一个是事务隔离级别的常量 另外一个是事务的传播行为常量（主要为了解决services层方法之间相互调用的问题 保证不同的services层方法之间的调用由同一个事务进行管理） TransactionStatus接口 – 事务的状态（是否新事务、是否已提交、是否有保存点、是否回滚） Spring的声明式事务管理： (基于AspectJ的xml方式)1.配置文件的配置：123456789101112131415161718192021&lt;!-- 配置平台事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务通知 --&gt;&lt;!-- tx:advice：对应的处理器类就是TransactionInterceptor类（实现了MethodInterceptor） --&gt;&lt;!-- TransactionInterceptor类实现事务是通过transaction-manager属性指定的值进行事务管理 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;&lt;!-- 设置事务管理信息 --&gt; &lt;tx:attributes&gt; &lt;!-- 增删改使用REQUIRED事务传播行为 --&gt; &lt;!-- 查询使用read-only --&gt; &lt;tx:method name=&quot;transfer*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 基于AspectJ + XML方式实现声明式事务 --&gt;&lt;aop:config&gt;&lt;!-- aop:advisor标签使用的是传统spring aop开发方式实现的 --&gt;&lt;!-- spring已经实现了该增强功能，spring使用的是实现MethodInterceptor接口的方式实现的 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;/&gt;&lt;/aop:config&gt; 2.Services层代码12345678910111213141516171819202122232425//@Transactional：标记该类的所有方法都已经被事务进行管理了，至于管理属性，不设置的话，都采取默认值@Transactional@Servicepublic class AccountServiceImpl implements AccountService &#123; @Resource private AccountDao accountDao; @Override public void transfer(String from, String to, double money) &#123; // 先查询from账户的钱 double fromMoney = accountDao.queryMoney(from); // 对from账户进行扣钱操作 accountDao.update(from, fromMoney - money); //手动制造异常 System.out.println(1/0); // 先查询from账户的钱 double toMoney = accountDao.queryMoney(to); // 对to账户进行加钱操作 accountDao.update(to, toMoney + money); &#125;&#125;","categories":[],"tags":[{"name":"Spring组件学习","slug":"Spring组件学习","permalink":"http://yoursite.com/tags/Spring组件学习/"}]},{"title":"Spring知识点总结（一）","slug":"Spring知识点总结（一）","date":"2019-01-02T15:16:23.000Z","updated":"2019-01-05T13:13:33.625Z","comments":true,"path":"2019/01/02/Spring知识点总结（一）/","link":"","permalink":"http://yoursite.com/2019/01/02/Spring知识点总结（一）/","excerpt":"","text":"SpringIoc：1.什么是Ioc容器：所谓的IoC容器就是指的Spring中Bean工厂里面的Map存储结构（存储了Bean的实例）。2.Spring中的框架工厂：ApplicationContext接口（）：实现了BeanFactory接口 实现ApplicationContext接口的工厂，可以获取到容器中具体的Bean对象BeanFactory工厂（是Spring框架早期的创建Bean对象的工厂接口）：其实通过源码分析，不管是BeanFactory还是ApplicationContext，其实最终的底层BeanFactory都是DefaultListableBeanFactory3.ApplicationContext和BeanFactory的区别？创建Bean对象的时机不同:BeanFactory采取延迟加载，第一次getBean时才会初始化Bean。ApplicationContext是加载完applicationContext.xml时，就创建具体的Bean对象的实例。（只对BeanDefition中描述为是单例的bean，才进行饿汉式加载）4.Web应用中创建IoC容器：1）web服务器（tomcat）启动会加载web.xml（启动ContextLoaderListener监听器，实现了ServletContextListener接口）2）ContextLoaderListener监听器会在web容器启动的时候，触发contextInitialized()3）contextInitialized()方法会调用initWebApplicationContext()方法，该方法负责创建Spring容器（DefaultListableBeanFactory）。4）ContextLoader类中创建Spring容器并初始化容器中的Bean实例5）最终调用configureAndRefreshWebApplicationContext方法中调用最终初始化Bean的refresh方法5.bean标签作用：用于配置对象让 spring 来创建的。默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。id：给对象在容器中提供一个唯一标识。用于获取对象。class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。scope：指定对象的作用范围6.bean的作用范围：单例对象：scope=”singleton”一个应用只有一个对象的实例。它的作用范围就是整个引用。生命周期：对象出生：当应用加载，创建容器时，对象就被创建了。对象活着：只要容器在，对象一直活着。对象死亡：当应用卸载，销毁容器时，对象就被销毁了。多例对象：scope=”prototype”每次访问对象时，都会重新创建对象实例。生命周期：对象出生：当使用对象时，创建新的对象实例。对象活着：只要对象在使用中，就一直活着。对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。7.实例化bean的三种方式?第一种：使用默认无参构造函数（重点）如果 bean 中没有默认无参构造函数，将会创建失败第二种：静态工厂（了解）模拟一个静态工厂，创建业务层实现类public class StaticFactory {public static UserService createUserService(){return new UserServiceImpl();}} 使用 StaticFactory 类中的静态方法 createUserService 创建对象，并存入 spring 容器 id 属性：指定 bean 的 id，用于从容器中获取 class 属性：指定静态工厂的全限定类名 factory-method 属性：指定生产对象的静态方法第三种：实例工厂（了解）拟一个实例工厂，创建业务层实现类 此工厂创建对象，必须现有工厂实例对象，再调用方法此种方式是：先把工厂的创建交给 spring 来管理。 然后在使用工厂的 bean 来调用里面的方法 factory-bean 属性：用于指定实例工厂 bean 的 id。 factory-method 属性：用于指定实例工厂中创建对象的方法。8.Spring依赖注入什么是依赖？依赖指的就是Bean实例中的属性属性分为：简单类型（8种基本类型和String类型）的属性、POJO类型的属性、集合数组类型的属性。什么是依赖注入？依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。为什么要进行依赖注入？我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取9.Spring依赖注入的方式1）构造函数注入2）set方法注入（重点） set方法注入又分为手动装配方式注入和自动装配方式注入。手动装配方式（XML方式）：bean标签的子标签property，需要在类中指定set方法。自动装配方式（注解方式）：@Autowired注解、@Resource注解。@Autowired：一部分功能是查找实例，从spring容器中根据类型（java类）获取对应的实例。另一部分功能就是赋值，将找到的实例，装配给另一个实例的属性值。（注意事项：一个java类型在同一个spring容器中，只能有一个实例）@Resource：一部分功能是查找实例，从spring容器中根据Bean的名称（bean标签的名称）获取对应的实例。另一部分功能就是赋值，将找到的实例，装配给另一个实例的属性值。10.依赖注入不同类型的属性（基于XML）简单类型（value）引用类型（ref）集合类型（数组） 数组或者List集合， Set集合 Map集合 Properties集合的方式11.依赖注入常用注解?@Component 把资源让 spring 来管理。相当于在 xml 中配置一个 bean。 @Controller、@Service、@Repository注解 是@Component的衍生注解?@Autowired默认按类型装配（byType）这个注解是spring自身的默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false)如果我们想使用名称装配可以结合@Qualifier注解进行使用?@Resource默认按照名称（byName）进行装配，名称可以通过name属性进行指定如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，当找不到与名称匹配的bean时才按照类型进行装配。12.Spring整合junit第一步：添加依赖 添加spring-test包即可。第二步：通过@RunWith注解，指定spring的运行器 Spring的运行器是SpringJunit4ClassRunner第三步：通过@ContextConfiguration注解，指定spring运行器需要的配置文件路径第四步：通过@Autowired注解给测试类中的变量注入数据13SpringAop的作用及优势是什么？作用：AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码（性能监视、事务管理、安全检查、缓存）在程序运行期间，不修改源码对已有方法进行增强。将业务逻辑和系统处理的代码（关闭连接、事务管理、操作日志记录）解耦。优势：减少重复代码提高开发效率维护方便14.AOP相关术语介绍 Joinpoint(连接点) – 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点 Pointcut(切入点) – 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 Advice(通知/增强) – 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Introduction(引介) – 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field Target(目标对象) – 代理的目标对象 Weaving(织入) – 是指把增强应用到目标对象来创建新的代理对象的过程 Proxy（代理） – 一个类被AOP织入增强后，就产生一个结果代理类 Aspect(切面) – 是切入点和通知的结合，以后咱们自己来编写和配置的15.AOP实现之AspectJ（了解）AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。对于这个过程，一般分为动态织入和静态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术ApectJ采用的就是静态织入的方式。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。16.Spring AOP是通过动态代理技术实现的而动态代理是基于反射设计的。（关于反射的知识，请自行学习）动态代理技术的实现方式有两种：基于接口的JDK动态代理和基于继承的CGLib动态代理。JDK动态代理：目标对象必须实现接口CGLib动态代理：目标对象不需要实现接口，底层是通过继承目标对象产生代理子对象（代理子对象中继承了目标对象的方法，并可以对该方法进行增强）17.基于AspectJ的XML实现和基于AspectJ的注解实现（源码就不贴了）18.SpringAop通知类型通知类型（五种）：前置通知、后置通知、最终通知、环绕通知、异常抛出通知。前置通知：执行时机：目标对象方法之前执行通知配置文件：&lt;aop:before method=”before” pointcut-ref=”myPointcut”/&gt;应用场景：方法开始时可以进行校验后置通知：执行时机：目标对象方法之后执行通知，有异常则不执行了配置文件：&lt;aop:after-returning method=”afterReturning” pointcut-ref=”myPointcut”/&gt;应用场景：可以修改方法的返回值最终通知：执行时机：目标对象方法之后执行通知，有没有异常都会执行配置文件：&lt;aop:after method=”after” pointcut-ref=”myPointcut”/&gt;应用场景：例如像释放资源环绕通知：执行时机：目标对象方法之前和之后都会执行。配置文件：&lt;aop:around method=”around” pointcut-ref=”myPointcut”/&gt;应用场景：事务、统计代码执行时机异常抛出通知：执行时机：在抛出异常后通知配置文件：&lt;aop:after-throwing method=” afterThrowing “ pointcut- ref=”myPointcut”/&gt;应用场景：包装异常","categories":[],"tags":[{"name":"Spring知识点总结（一）","slug":"Spring知识点总结（一）","permalink":"http://yoursite.com/tags/Spring知识点总结（一）/"}]},{"title":"SpringIoc源码分析（一）","slug":"SpringIoc源码分析（一）","date":"2018-12-27T12:03:38.000Z","updated":"2019-01-02T15:25:17.180Z","comments":true,"path":"2018/12/27/SpringIoc源码分析（一）/","link":"","permalink":"http://yoursite.com/2018/12/27/SpringIoc源码分析（一）/","excerpt":"","text":"IoC 全称为 Inversion of Control，翻译为 “控制反转”，它还有一个别名为 DI（Dependency Injection）,即依赖注入。谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。控制什么：控制对象。为何是反转：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。哪些方面反转了：所依赖对象的获取被反转了。IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。Spring IoC容器的初始化过程主要包括以下几个步骤：1.获取Resouce实例。加载XML配置文件，封装成Resouce实例。这时Resouce实例中已经有了配置文件的路径等信息。2.获取Document实例。通过Resource，读取XML配置文件，封装成Document实例。这时Document实例中已经有了配置文件中的标签。3.获取BeanDefinition实例。解析Document实例中的标签，最终获得BeanDefinition实例。这时BeanDefinition实例中已经有了bean的id、name、alias、class等信息。4.注册BeanDefinition。这个注册过程把BeanDefinition向IOC容器进行注册，相当于将bean的name作为key，BeanDefinition作为value，放入一个map中。IOC容器初始化过程一般不包含Bean加载的实现。Bean加载一般发生在应用第一次通过getBean向容器索取Bean的时候。但有一个例外：如果在XML文件中为Bean定义了lazy-init属性，那么Bean的加载在IOC容器初始化时就预先完成了。SpringIoc容器的bean的加载步骤总结如下：1.获取bean的真正名字（name可能是别名或者FactoryBean）。2.尝试从缓存中加载单例bean。单例bean在同一个Spring容器中只创建一次，获取bean的时候，尝试从缓存加载bean。首先从一级缓存singletonObjects中获取，如果没有获取到，且bean正在创建过程中 （isSingletonCurrentlyInCreation()为true），则尝试从二级缓存earlySingletonObjects中获取，如果还获取不到，就求助于三级缓存singletonFactories。因为spring创建单例bean的时候，存在循环依赖的问题。比如创建bean a的时候发现bean a引用了bean b，此时会去创建bean b，但又发现bean b引用了bean c，所以此时会去创建bean c，在创建bean c的过程中发现bean c引用bean a。为了避免循环依赖，Spring采取了一种将正在创建的bean实例提早暴露加入到singletonFactories缓存中，一旦下一个bean创建的时候需要依赖上个bean，则直接使用singletonFactories来获取bean。提前暴露bean实例到缓存的时机是在bean实例创建（调用构造方法）之后，初始化bean实例（属性注入）之前3.如果从缓存中加载到了单例bean，从bean实例中获取对象并返回。从缓存中加载到的bean并不一定是我们最终想要的bean。 BeanFactory是用于管理bean的一个工厂。FactoryBean是一种特殊的bean。在BeanFactory中管理两种bean，一种是标准的Java bean，另一种实现了FactoryBean接口的bean。通过beanFactory.getBean(beanName)从BeanFactory获取bean实例时，对于标准的Java bean，返回的是类自身的实例。而对于FactoryBean，返回的不是自身的实例，而是该FactoryBean的getObject方法所返回的实例。如果想要获取FactoryBean的实例，可以通过getBean(&amp;+beanName)这种方法来获取。4.原型模式的依赖检查。prototype的Bean，Spring容器不进行缓存。如果是prototype的Bean处于正在创建的状态，直接抛出异常。5.递归加载依赖的bean。如果此bean依赖了其他的bean，则需要递归加载依赖的bean。6.因为在缓存中没有加载到单例bean。 如果是单例模式，创建单例bean。如果是原型模式，创建原型bean。1.清除缓存。如果是bean是单例bean，需要首先清除缓存。2.创建bean实例。在spring中有三中实例化bean的方式：1)使用构造器实例化；采用这种实例化方式要注意的是：要实例化的类中如果有构造器的话，一定要有一个无参的构造器。2)使用静态工厂方法实例化；3)使用实例化工厂方法实例化。3.避免循环依赖。为了避免循环依赖，可以在 bean初始化完成前将创建实例的 ObjectFactory加入工厂。4.属性注入。将所有属性填充至bean的实例中。5.初始化bean。6.循环依赖检查。Sping 中解决循环依赖只对单例有效，而对于prototype的bean，Spring 没有好的解决办法，唯一要做的就是抛出异常。在这个步骤里面会检测已经加载的 bean 是否已经出现了依赖循环，并判断是否需要抛出异常。7.注册DisposableBean。8.完成创建并返回。bean的生命周期1.实例化。Spring对Bean进行实例化（默认是单例）2.属性注入。Spring将值和Bean的引用注入进Bean对应的属性中3.3初始化。如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()方法。如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。如果Bean实现了ApplicationContextAwaer接口，Spring容器将调用setApplicationContext(ApplicationContext ctx)方法，把应用上下文作为参数传入。如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessBeforeInitialization方法。如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法，作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法。如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessAfterInitialization方法。4.注册DispostbleBean。5.经过以上的工作后，Bean将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁。Bean实例销毁前，如果Bean实现了DispostbleBean接口，Spring将调用它的destory方法。 Spring单例对象的初始化其实可以分为三步：（实例化、填充属性、初始化）这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，长大成人，进去了一级缓存singletonObjects中，","categories":[],"tags":[{"name":"SpringIoc源码分析（一）","slug":"SpringIoc源码分析（一）","permalink":"http://yoursite.com/tags/SpringIoc源码分析（一）/"}]},{"title":"Mybatis源码分析（三）","slug":"Mybatis源码分析（三）","date":"2018-12-26T14:11:41.000Z","updated":"2018-12-27T12:08:20.729Z","comments":true,"path":"2018/12/26/Mybatis源码分析（三）/","link":"","permalink":"http://yoursite.com/2018/12/26/Mybatis源码分析（三）/","excerpt":"","text":"动态sql标签—-for eachfor each标签的主要参数：item index collection open seperator closeitem：表示集合中示每一个元素进行迭代时的别名index：表示集合中元素进行迭代时的位置collection：表示传入参数的类型open/close：表示以什么开始以什么结束sepeator：表示每次迭代之间以什么作为分割符下面举几个例子：Mybatis的级联操作：一般来说只会使用级联查询，其他的如级联删除等维护的成本较大，一般不会使用级联查询—一对多查询（部门和职员之间的一对多的关系 在部门的实体类中声明list类型的数组，里面是职员类型的对象，有两种方式） 级联查询–多对一查询（根据职员的编号查询员工的基本信息和部门的基本信息，员工的实体类型中有一个部门类型的参数） Mybatis分页（PageHelper插件）1.引入pagehelper的依赖 &lt; dependency &gt;&#8194;&#8194;&#8194; &lt; groupId&gt;com.github.pagehelper&lt; /groupId &gt; &#8194;&#8194;&#8194; &lt; artifactId &gt;pagehelper&lt; /artifactId &gt; &#8194;&#8194;&#8194; &lt; version &gt;4.1.6&lt; /version &gt; &lt; /dependency &gt; 2.在Mybatis配置文件中进行配置（plugins应该在environments的上面） &lt; plugin interceptor=”com.github.pagehelper.PageHelper” &gt; &#8194;&#8194;&#8194; &lt; property name=”dialect” value=”mysql”/ &gt; &#8194;&#8194;&#8194; &lt; property name=”offsetAsPageNum” value=”false”/ &gt; &#8194;&#8194;&#8194; &lt; property name=”rowBoundsWithCount” value=”false”/ &gt; &#8194;&#8194;&#8194; &lt; property name=”pageSizeZero” value=”true”/&gt; &#8194;&#8194;&#8194; &lt; property name=”reasonable” value=”false”/ &gt; &#8194;&#8194;&#8194; &lt; property name=”supportMethodsArguments” value=”false”/&gt; &#8194;&#8194;&#8194; &lt; property name=”returnPageInfo” value=”none”/&gt; &lt; /plugin &gt;3.具体使用在查询之前进行分页： PageHelper.startPage(1,10,true); //第一页 每页显示10条想研究源码的：请看http://www.ccblog.cn/92.htm","categories":[],"tags":[{"name":"Mybatis源码分析（三）","slug":"Mybatis源码分析（三）","permalink":"http://yoursite.com/tags/Mybatis源码分析（三）/"}]},{"title":"Mybatis源码分析（二）","slug":"Mybatis源码分析（二）","date":"2018-12-25T12:42:54.000Z","updated":"2018-12-27T02:39:09.197Z","comments":true,"path":"2018/12/25/Mybatis源码分析（二）/","link":"","permalink":"http://yoursite.com/2018/12/25/Mybatis源码分析（二）/","excerpt":"","text":"由于Mybatis和Spring框架中都大量使用了代理模式，所以先讲一下代理模式，据我所知，代理模式一般有两种实现，一种是通过组合的方式来实现代理模式这种实现方式比较简单，可以看看菜鸟教程的代理模式：http://www.runoob.com/design-pattern/proxy-pattern.html， 但是在框架中都不会使用这种方式来实现代理，一般是使用java的反射机制来实现的，比如说Mybatis的封装jdbc的操作就是用jdk的动态代理来实现的代理模式：1.作用：将主要业务和次要业务进行松耦合的处理 2.JDK代理模式实现 1 接口角色： 定义所有需要被监听行为 2.接口实现类：中国人，印度人 3.通知类： 1）次要业务进行具体实现 2）通知JVM,当前被拦截的主要业务方法与次要业务方法应该如何绑定执行 4.监控对象（代理对象） 1） 被监控实例对象 2） 需要被监控监控行为 3）具体通知类实例对象Mybatis中Mapper配置文件详解1.#{}的参数问题 #{}实现的是向prepareStatement中的预处理语句中设置参数值，sql语句中#{}表示一个占位符即 ？ 使用#{参数名},将参数的内容添加到sql语句中指定位置. 如果当前sql语句中只有一个参数,此时参数名称可以随意定义 但是,如果当前sql语句有多个参数,此时参数名称应该是与当前表关联[实体类的属性名]或则[Map集合关键字] 可以采用一下两种方式来对sql语句进行参数的赋值操作 2.#和$的区别其实#就是起一个占位符的作用，就是？，而$符号则是采用直接赋值的方式，简单来说如果使用#{}，会将{}里面的传入的值自动解析成为带引号的值，如果使用$就不会带引号，举个例子在登录的时候有一条查询语句，写了一个错误的用户名，用$符号进行解析的时候就是select from test where username=’张三’ or ‘1’=’1’ and password=’13’;但是用#解析的时候就会加上引号，就可以防止sql注入，大多数情况下我们都会使用#符号的方式来避免sql注入，但是在一些特殊情况就会使用到$符号:比如说现在有两张数据库表，在一条sql语句中要对数据库的表名进行动态的改变，这时候必须用$符号 还有就是说动态的指定查询语句中的排序字段时，必须使用$ select from dept order by ${name}3.Mybatis–Mapper映射文件之resultMap先说一下resultType吧，就是说如果sql映射文件的返回的结果集刚好是我们定义的实体类对象，这个时候就用resultType，但是当实体类的参数和数据库中的字段不一样时，java通过反射机制进行赋值的时候就会出错，这个时候就要运用resultMap把数据库的字段和实体类的参数进行一一对应1）ResultMap中的constructor标签（这个不是很重要，可以选择性忽略）作用：有可能存在一种情况就是说实体类有一个参数是数据库对应表中的字段所没有的，这个时候可以通过构造函数算出这个实体类的参数的值，代码如下 配置文件如下： ###如果说数据库中的字段是tb_name话，Mybatis会把横杠去掉并把后面的第一个字母变为大写，就是tbName再去实体类中进行匹配4.Mybatis动态sqlif：根据if标签里面的条件是否为真来决定标签里面的内容是否可以到sql语句中choose when othenwise —-分支选择条件where： 1.如果where标签内部所有的判断都不成立。在查询语句中是不会出现where或则只出现 where1=1 2.where标签中，将第一个满足条件的语句中前部包含【and ,or】自动取消set:一般用于更新语句中动态指定需要更新字段信息，往往需要与if标签使用，自动将最后一个更新字段后面“，”取消trim:自定义第一个满足条件前部的代替内容也可以自定义最后一个满足条件后面的代替内容","categories":[],"tags":[{"name":"Mybatis源码分析（二）","slug":"Mybatis源码分析（二）","permalink":"http://yoursite.com/tags/Mybatis源码分析（二）/"}]},{"title":"Mybatis源码分析（一）","slug":"Mybatis源码分析（一）","date":"2018-12-25T03:37:49.000Z","updated":"2018-12-29T02:31:28.001Z","comments":true,"path":"2018/12/25/Mybatis源码分析（一）/","link":"","permalink":"http://yoursite.com/2018/12/25/Mybatis源码分析（一）/","excerpt":"","text":"关于具体的框架的搭建就不往上贴了，不会的话看一下这个链接：https://www.cnblogs.com/fangjet/p/7639606.html Mybatis框架源码分析：//读取配置文件InputStream inputstream=Resources.getResourcesAsStream(“mybatis-config.xml”);//创建sqlSessionFactory对象SqlSessionFactory sqlsessionFactory=new SqlSessionFactoryBuilder() .build(inputStream);//创建SqlSession对象session=sqlsessionFactory.openSession();//操作session.insert(“insertStu”,student)//提交session.commit();session.close(); SqlSessionFactory sqlsessionFactory=new SqlSessionFactoryBuilder().build(inputStream);首先把MyBatis的配置文件封装成IO流的方式，再者就是创建sqlsessionFactory的过程，这里面采用了工厂模式来生成sqlsessionFactory的实例，用SqlSessionFactoryBuilder的build方法，build方法里面有一个自己的重载的过程，这是因为在这里可以改变Mybatis配置文件中的properties,environment等信息，真正在build方法里面实现的还是用XMLConfigBuilder的parse（）方法来实现对mybatis配置文件的一个解析，这个parse方法返回的configuration对象就有了配置文件的一些信息，这个configuration对象会作为build方法的一个参数，调用build方法其实就是新建了一个DefaultSqlSessionFactory对象，他是SqlSessionFactory的实现类，也就是说最后返回的就是DefaultSqlSessionFactory对象 session=sqlsessionFactory.openSession();由sqlsessionFactory这个工厂来创造sqlsession对象，返回的还是defaultSqlSession对象，这个对象里面有一些属性，比如dirty，autocommit，executor等一些属性 session.insert(“insertStu”,student) （insertStu是映射文件的id）这个方法里面可以帮我们找到三个问题的答案:1.mybatis是如何把insertStu与映射文件的id对应起来的？2.mybatis如何把数据绑定到sql语句中？3.mybatis如何输送sql语句？insert方法其实调用的是update方法，里面会传入上面的两个参数，当sqlsession对象在执行的时候，他要根据configuration对象的mapper映射的id找到当前执行的sql语句，同时通过对应关系把值赋值到对应的 sql语句中 ，下来就是执行器Executor进行sql语句的执行工作，这里面应该就是封装的一些jdbc的操作，来完成对数据库的交互工作，在这个操作之前，会有MapperStatement对象将赋值内容和sql占位符进行绑定的一个操作。 session.commit();这个里面的主要是通过sqlsession对象里面的dirty属性来决定数据库的事务提交的方式，具体就是当dirty属性为true时，就是当sql语句执行完毕后，事务可以进行提交，当dirty属性为false时，当sql语句执行完毕后，事务可以进行回滚 Mybatis标签解析：mybatis的sql语句的配置文件不能为空，其次就是有一个xml解析器会把配置文件里面的sql语句的参数先全部换为占位符，再把参数名放在一个list集合中，等到使用的时候，使用反射机制把list数组里面的值读取出来做赋值处理 Mybatis标签解析—-TypeHandle 每当Mybatis设置参数到PreparedStatemnet或者从ResultSet 结果集中取得值时，就会使用TypeHandle对象来处理数据库类型与java类型之间的转换，一般来说，类型转换可以满足日常的需求，但我们也可以自定义一个类型转换器，比如说数据库的flag字段是int类型，到Java代码中必须转换为Boolean类型，这是就需要自定义类型转换器 （1）实体类 （2） 表中字段 （3） 开发自定义类型转换器 （4） 在MyBatis核心配置文件注册自定义类型转换器 这样其实是一个全局生效的配置，无关哪个数据库，无关哪张表，主要有这两个字段的，都会走自定义的类型转换器（1） 在Mapper.xml文件中指定使用自定义类型转换器场合 （2） 在查询Statement中指定对应的ResultMap 这个意思就是说只有执行这个select语句的时候，才会发生类型的转换，相当于给定了类型转换的时机 Mybatis标签解析—-ObjectFactory 这个标签的作用就是说，当Mybatis查询完毕后，是要把查询后的ResultSet结果集转换为对应的实体对象的，而ObjectFacory是负责创建这个对象的假如有一种情况就是说实体类中有一个字段country但是数据库的表中没有这个字段这时候可以自定义一个ObjectFactory来实现这个需求，就是重新定义类实例创建的规则（1）自定义ObjectFactory工厂 （2） 在MyBatis核心文件中注册自定义工厂 Mybatis解析—plugins拦截器 拦截器的一个作用就是我们可以拦截某些方法的调用，我们可以选择在这些被拦截的方法执行前后加上某些逻辑，也可以在执行这些被拦截的方法时执行自己的逻辑而不再执行被拦截的方法。Mybatis拦截器设计的一个初衷就是为了供用户在某些时候可以实现自己的逻辑而不必去动Mybatis固有的逻辑。打个比方，对于Executor，Mybatis中有几种实现：BatchExecutor、ReuseExecutor、SimpleExecutor和CachingExecutor。这个时候如果你觉得这几种实现对于Executor接口的query方法都不能满足你的要求，那怎么办呢？是要去改源码吗？当然不。我们可以建立一个Mybatis拦截器用于拦截Executor接口的query方法，在拦截之后实现自己的query方法逻辑，之后可以选择是否继续执行原来的query方法。 对于拦截器Mybatis为我们提供了一个Interceptor接口，通过实现该接口就可以定义我们自己的拦截器。我们先来看一下这个接口的定义： 我们可以看到在该接口中一共定义有三个方法，intercept、plugin和setProperties。plugin方法是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。当返回的是代理的时候我们可以对其中的方法进行拦截来调用intercept方法，当然也可以调用其他方法，这点将在后文讲解。setProperties方法是用于在Mybatis配置文件中指定一些属性的。 定义自己的Interceptor最重要的是要实现plugin方法和intercept方法，在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象。而intercept方法就是要进行拦截的时候要执行的方法。 对于plugin方法而言，其实Mybatis已经为我们提供了一个实现。Mybatis中有一个叫做Plugin的类，里面有一个静态方法wrap(Object target,Interceptor interceptor)，通过该方法可以决定要返回的对象是目标对象还是对应的代理。 对于实现自己的Interceptor而言有两个很重要的注解，一个是@Intercepts，其值是一个@Signature数组。@Intercepts用于表明当前的对象是一个Interceptor，而@Signature则表明要拦截的接口、方法以及对应的参数类型。来看一个自定义的简单Interceptor： 然后在MyBatis核心配置文件注册自定义拦截器 MyBatis自定义拦截器，可以拦截接口只有四种.Executor.class， StatementHandler.class（生成一个preparement对象，并把sql语句放到preparement里面）ParameterHandler.class,（参数处理器主要是把传入的参数对象填充到sql映射文件的标签里面）ResultSetHandler.class（当Mybatis进行查询的时候，进行当前数据行里面的值和对象的哪一个参数进行匹配的工作）","categories":[],"tags":[{"name":"Mybatis源码分析（一）","slug":"Mybatis源码分析（一）","permalink":"http://yoursite.com/tags/Mybatis源码分析（一）/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-24T01:30:00.616Z","updated":"2018-12-24T01:30:00.617Z","comments":true,"path":"2018/12/24/hello-world/","link":"","permalink":"http://yoursite.com/2018/12/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}